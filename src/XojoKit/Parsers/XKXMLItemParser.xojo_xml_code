<?xml version="1.0" encoding="UTF-8"?>
<RBProject version="2022r1" FormatVersion="2" MinIDEVersion="20070100">
<block type="Module" ID="1962539007">
 <ObjName>XKXMLItemParser</ObjName>
 <ObjContainerID>1087893503</ObjContainerID>
 <IsClass>1</IsClass>
 <Interfaces>XKItemParser</Interfaces>
 <ItemFlags>1</ItemFlags>
 <IsInterface>0</IsInterface>
 <Compatibility></Compatibility>
 <Method>
  <ItemName>FinishParsingComputedProperty</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>Takes a partially parsed computed property and completes it by parsing the contents of the passed "Property" XML node.</CodeDescription>
  <PartID>1899919359</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function FinishParsingComputedProperty(cp As XKProperty, node As XmlNode) As XKProperty</SourceLine>
   <SourceLine>/// Takes a partially parsed computed property and completes it by </SourceLine>
   <SourceLine>/// parsing the contents of the passed "Property" XML node.</SourceLine>
   <SourceLine>///</SourceLine>
   <SourceLine>/// Assumes `node` is a valid property node that was used to generate `p`.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var iLimit As Integer = node.ChildCount - 1</SourceLine>
   <SourceLine>For i As Integer = 0 To iLimit</SourceLine>
   <SourceLine>Var child As XmlNode = node.Child(i)</SourceLine>
   <SourceLine>Select Case child.Name</SourceLine>
   <SourceLine>Case "GetAccessor"</SourceLine>
   <SourceLine>// Getter.</SourceLine>
   <SourceLine>cp.GetterLines = ParseGetterOrSetter(child)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case "SetAccessor"</SourceLine>
   <SourceLine>// Setter.</SourceLine>
   <SourceLine>cp.SetterLines = ParseGetterOrSetter(child)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Select</SourceLine>
   <SourceLine>Next i</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// The signature is just the name.</SourceLine>
   <SourceLine>cp.Signature = cp.Name</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Return cp</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>cp As XKProperty, node As XmlNode</ItemParams>
  <ItemResult>XKProperty</ItemResult>
 </Method>
 <Method>
  <ItemName>FinishParsingProperty</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>Takes a partially parsed regular property that is known to not be a computed property and completes it by parsing the contents of the passed "Property" XML node.</CodeDescription>
  <PartID>1937420287</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function FinishParsingProperty(prop As XKProperty, node As XmlNode) As XKProperty</SourceLine>
   <SourceLine>/// Takes a partially parsed regular property that is known to not be a computed property and completes it by </SourceLine>
   <SourceLine>/// parsing the contents of the passed "Property" XML node.</SourceLine>
   <SourceLine>///</SourceLine>
   <SourceLine>/// Assumes `node` is a valid property node that was used to generate `prop`.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>prop.IsArray = If(prop.Name.IndexOf("(") = -1, False, True)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var iLimit As Integer = node.ChildCount - 1</SourceLine>
   <SourceLine>For i As Integer = 0 To iLimit</SourceLine>
   <SourceLine>Var child As XmlNode = node.Child(i)</SourceLine>
   <SourceLine>Select Case child.Name</SourceLine>
   <SourceLine>Case "ItemDeclaration"</SourceLine>
   <SourceLine>Var tmp() As String = child.FirstChild.Value.Split(" As ")</SourceLine>
   <SourceLine>Var typeDefault() As String = tmp(1).Split(" = ")</SourceLine>
   <SourceLine>prop.DefaultValue = If(typeDefault.Count = 1, "", typeDefault(1).Trim)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Select</SourceLine>
   <SourceLine>Next i</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// The signature is just the name.</SourceLine>
   <SourceLine>prop.Signature = prop.Name</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Return prop</SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>prop As XKProperty, node As XmlNode</ItemParams>
  <ItemResult>XKProperty</ItemResult>
 </Method>
 <Method>
  <ItemName>Parse</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>Parses the contents of an item into its constituent methods, properties, events and notes.</CodeDescription>
  <PartID>231014399</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Sub Parse(ByRef item As XKItem, options As XKOptions)</SourceLine>
   <SourceLine>/// Parses the contents of an item into its constituent methods, properties, events and notes.</SourceLine>
   <SourceLine>///</SourceLine>
   <SourceLine>/// The XML to parse should be stored in `item.XML`.</SourceLine>
   <SourceLine>/// Part of the XKItemParser interface.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Sanity check.</SourceLine>
   <SourceLine>If item.XML = Nil Then</SourceLine>
   <SourceLine>Raise New XKException("Unable to parse item as its XML property is Nil.")</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Keep a reference to the parsing options.</SourceLine>
   <SourceLine>mOptions = options</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// We need to track a couple of flags.</SourceLine>
   <SourceLine>Var isClass, isInterface As Boolean = False</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var iLimit As Integer = item.XML.ChildCount - 1</SourceLine>
   <SourceLine>For i As Integer = 0 To iLimit</SourceLine>
   <SourceLine>Var node As XmlNode = item.XML.Child(i)</SourceLine>
   <SourceLine>Select Case node.Name</SourceLine>
   <SourceLine>Case "IsClass"</SourceLine>
   <SourceLine>isClass = If(node.FirstChild.Value = "0", False, True)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case "IsInterface"</SourceLine>
   <SourceLine>isInterface = If(node.FirstChild.Value = "0", False, True)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case "Attributes"</SourceLine>
   <SourceLine>item.Attributes_ = ParseAttributesNode(node)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case "SuperClass"</SourceLine>
   <SourceLine>item.Superclass = If(node.FirstChild = Nil, "", node.FirstChild.Value)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case "IsApplicationObject"</SourceLine>
   <SourceLine>item.IsApplicationObject = If(node.FirstChild.Value = "0", False, True)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case "Method"</SourceLine>
   <SourceLine>item.Methods.Add(ParseMethod(node))</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case "Constant"</SourceLine>
   <SourceLine>item.Constants.Add(ParseConstant(node))</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case "Property"</SourceLine>
   <SourceLine>// Could be either a regular property or a computed property.</SourceLine>
   <SourceLine>Var prop As XKProperty = ParseProperty(node)</SourceLine>
   <SourceLine>If prop &lt;&gt; Nil Then</SourceLine>
   <SourceLine>If prop.IsComputed Then</SourceLine>
   <SourceLine>// Parse the rest of the node for the computed property specific data.</SourceLine>
   <SourceLine>item.Properties.Add(FinishParsingComputedProperty(prop, node))</SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine>// Parse the rest of the node for the regular property specific data.</SourceLine>
   <SourceLine>item.Properties.Add(FinishParsingProperty(prop, node))</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case "Note"</SourceLine>
   <SourceLine>item.Notes.Add(ParseNote(node))</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case "DelegateDeclaration"</SourceLine>
   <SourceLine>item.Delegates.Add(ParseDelegate(node))</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case "Enumeration"</SourceLine>
   <SourceLine>item.Enums.Add(ParseEnum(node))</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case "Hook"</SourceLine>
   <SourceLine>// Event definition (NOT an event implementation).</SourceLine>
   <SourceLine>item.EventDefinitions.Add(ParseEventDefinition(node))</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case "HookInstance"</SourceLine>
   <SourceLine>// Event *implementation* (NOT an event definition).</SourceLine>
   <SourceLine>item.Events.Add(ParseEvent(node))</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case "Structure"</SourceLine>
   <SourceLine>item.Structures.Add(ParseStructure(node))</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Select</SourceLine>
   <SourceLine>Next i</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Determine the type of item by analysing the isClass and isInterface flags.</SourceLine>
   <SourceLine>If isInterface Then</SourceLine>
   <SourceLine>item.Type = XojoKit.ItemTypes.Interface_</SourceLine>
   <SourceLine>ElseIf isClass Then</SourceLine>
   <SourceLine>item.Type = XojoKit.ItemTypes.Class_</SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine>item.Type = XojoKit.ItemTypes.Module_</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>End Sub</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>ByRef item As XKItem, options As XKOptions</ItemParams>
  <ItemResult></ItemResult>
 </Method>
 <Method>
  <ItemName>ParseProperty</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>Takes a "Property" XML node and returns an abstract property comprising the common data of both regular and computed properties.</CodeDescription>
  <PartID>1031852031</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function ParseProperty(node As XmlNode) As XKProperty</SourceLine>
   <SourceLine>/// Takes a "Property" XML node and returns a property comprising the common data of both </SourceLine>
   <SourceLine>/// regular and computed properties.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Default to a regular property.</SourceLine>
   <SourceLine>Var prop As New XKProperty(XojoKit.MemberTypes.Property_)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>If node = Nil Then Return Nil</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var iLimit As Integer = node.ChildCount - 1</SourceLine>
   <SourceLine>For i As Integer = 0 To iLimit</SourceLine>
   <SourceLine>Var child As XmlNode = node.Child(i)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Select Case child.Name</SourceLine>
   <SourceLine>Case "ItemName"</SourceLine>
   <SourceLine>prop.Name = child.FirstChild.Value</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case "ItemFlags"</SourceLine>
   <SourceLine>prop.Scope = ScopeFromXMLInteger(Integer.FromString(child.FirstChild.Value))</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case "CodeDescription"</SourceLine>
   <SourceLine>prop.Description = If(child.FirstChild &lt;&gt; Nil, child.FirstChild.Value, "")</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case "IsShared"</SourceLine>
   <SourceLine>prop.IsShared = If(child.FirstChild.Value = "0", False, True)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case "Attributes"</SourceLine>
   <SourceLine>prop.Attributes_ = ParseAttributesNode(child)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case "SetAccessor", "GetAccessor"</SourceLine>
   <SourceLine>prop.IsComputed = True</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case "ItemDeclaration"</SourceLine>
   <SourceLine>Var tmp() As String = child.FirstChild.Value.Split(" As ")</SourceLine>
   <SourceLine>Var typeDefault() As String = tmp(1).Split(" = ")</SourceLine>
   <SourceLine>prop.Type = typeDefault(0)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case "ItemSource"</SourceLine>
   <SourceLine>// Note.</SourceLine>
   <SourceLine>prop.NoteLines = ParsePropertyNote(child)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Select</SourceLine>
   <SourceLine>Next i</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// If this is a computed property, update its type to match.</SourceLine>
   <SourceLine>If prop.IsComputed Then</SourceLine>
   <SourceLine>prop.MemberType = XojoKit.MemberTypes.ComputedProperty_</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Exclude this member?</SourceLine>
   <SourceLine>prop.IsExcluded = XKProject.ShouldExcludeMember(prop, mOptions)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Return prop</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>node As XmlNode</ItemParams>
  <ItemResult>XKProperty</ItemResult>
 </Method>
 <Method>
  <ItemName>ParseAttributesNode</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>Takes an "Attributes" XML node and returns the attributes as an array of Pairs. Left = Key (String), Right = Value (String).</CodeDescription>
  <PartID>35008511</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function ParseAttributesNode(node As XmlNode) As Pair()</SourceLine>
   <SourceLine>/// Takes an "Attributes" XML node and returns the attributes as an array of Pairs.</SourceLine>
   <SourceLine>/// Left = Key (String), Right = Value (String).</SourceLine>
   <SourceLine>///</SourceLine>
   <SourceLine>/// ```</SourceLine>
   <SourceLine>/// &lt;Attributes&gt;MySuperAttribute, AttributeWithValue = "Hello World"&lt;/Attributes&gt;</SourceLine>
   <SourceLine>/// ```</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var atts() As Pair</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>If node.FirstChild = Nil Then Return atts</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var rawValue As String = node.FirstChild.Value.Trim</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var rawAtts() As String = rawValue.Split(",")</SourceLine>
   <SourceLine>For Each rawAtt As String In rawAtts</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var keyValues() As String = rawAtt.Split("=")</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>If keyValues.Count = 1 Then</SourceLine>
   <SourceLine>atts.Add(keyValues(0).Trim : "")</SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine>atts.Add(keyValues(0).Trim : keyValues(1).Trim)</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>Next rawAtt</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Return atts</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>node As XmlNode</ItemParams>
  <ItemResult>Pair()</ItemResult>
 </Method>
 <Method>
  <ItemName>ParseConstant</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>Parses an XML "Constant" node into an `XKConstant`.</CodeDescription>
  <PartID>754810879</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function ParseConstant(node As XmlNode) As XKConstant</SourceLine>
   <SourceLine>/// Parses an XML "Constant" node into an `XKConstant`.</SourceLine>
   <SourceLine>///</SourceLine>
   <SourceLine>/// Assumes that `node` has already been validated to be a "Constant" node.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var con As New XKConstant</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// We set this to False as I'm not sure when it's supposed to be True. Ah the joys of reverse engineering...</SourceLine>
   <SourceLine>con.IsDynamic = False</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var iLimit As Integer = node.ChildCount - 1</SourceLine>
   <SourceLine>For i As Integer = 0 To iLimit</SourceLine>
   <SourceLine>Var child As XmlNode = node.Child(i)</SourceLine>
   <SourceLine>Select Case child.Name</SourceLine>
   <SourceLine>Case "Attributes"</SourceLine>
   <SourceLine>con.Attributes_ = ParseAttributesNode(child)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case "CodeDescription"</SourceLine>
   <SourceLine>con.Description = If(child.FirstChild &lt;&gt; Nil, child.FirstChild.Value, "")</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case "ConstantInstance"</SourceLine>
   <SourceLine>con.Variants.Add(ParseConstantVariant(child))</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case "ItemDef"</SourceLine>
   <SourceLine>con.DefaultValue = If(child.FirstChild &lt;&gt; Nil, child.FirstChild.Value, "")</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case "ItemFlags"</SourceLine>
   <SourceLine>con.Scope = ScopeFromXMLInteger(Integer.FromString(child.FirstChild.Value))</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case "ItemName"</SourceLine>
   <SourceLine>con.Name = child.FirstChild.Value</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case "ItemType"</SourceLine>
   <SourceLine>con.Type = If(child.FirstChild &lt;&gt; Nil, child.FirstChild.Value, "")</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Select</SourceLine>
   <SourceLine>Next i</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// The signature is just the name.</SourceLine>
   <SourceLine>con.Signature = con.Name</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Exclude this member?</SourceLine>
   <SourceLine>con.IsExcluded = XKProject.ShouldExcludeMember(con, mOptions)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Return con</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>node As XmlNode</ItemParams>
  <ItemResult>XKConstant</ItemResult>
 </Method>
 <Method>
  <ItemName>ParseConstantVariant</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>Parses an XML "ConstantInstance" node into an `XKConstantVariant`.</CodeDescription>
  <PartID>369125375</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function ParseConstantVariant(node As XmlNode) As XKConstantVariant</SourceLine>
   <SourceLine>/// Parses an XML "ConstantInstance" node into an `XKConstantVariant`.</SourceLine>
   <SourceLine>///</SourceLine>
   <SourceLine>/// Assumes that `node` has already been validated to be a "ConstantInstance" node.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var cv As New XKConstantVariant</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var iLimit As Integer = node.ChildCount - 1</SourceLine>
   <SourceLine>For i As Integer = 0 To iLimit</SourceLine>
   <SourceLine>Var child As XmlNode = node.Child(i)</SourceLine>
   <SourceLine>Select Case child.Name</SourceLine>
   <SourceLine>Case "ItemPlatform"</SourceLine>
   <SourceLine>cv.Platform = If(child.FirstChild = Nil, "", child.FirstChild.Value)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case "ItemLanguage"</SourceLine>
   <SourceLine>cv.Language = If(child.FirstChild = Nil, "", child.FirstChild.Value)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case "ItemDef"</SourceLine>
   <SourceLine>cv.Value = If(child.FirstChild = Nil, "", child.FirstChild.Value)</SourceLine>
   <SourceLine>End Select</SourceLine>
   <SourceLine>Next i</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Return cv</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>node As XmlNode</ItemParams>
  <ItemResult>XKConstantVariant</ItemResult>
 </Method>
 <Method>
  <ItemName>ParseDelegate</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>Parses an XML "DelegateDeclaration" node into an `XKDelegate`.</CodeDescription>
  <PartID>74899455</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function ParseDelegate(node As XmlNode) As XKDelegate</SourceLine>
   <SourceLine>/// Parses an XML "DelegateDeclaration" node into an `XKDelegate`. </SourceLine>
   <SourceLine>///</SourceLine>
   <SourceLine>/// Assumes that `node` has already been validated to be a "DelegateDeclaration" node.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var d As New XKDelegate</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var iLimit As Integer = node.ChildCount - 1</SourceLine>
   <SourceLine>For i As Integer = 0 To iLimit</SourceLine>
   <SourceLine>Var child As XmlNode = node.Child(i)</SourceLine>
   <SourceLine>Select Case child.Name</SourceLine>
   <SourceLine>Case "ItemName"</SourceLine>
   <SourceLine>d.Name = child.FirstChild.Value</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case "ItemFlags"</SourceLine>
   <SourceLine>d.Scope = ScopeFromXMLInteger(Integer.FromString(child.FirstChild.Value))</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case "CodeDescription"</SourceLine>
   <SourceLine>d.Description = If(child.FirstChild &lt;&gt; Nil, child.FirstChild.Value, "")</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case "ItemResult"</SourceLine>
   <SourceLine>d.ReturnType = If(child.FirstChild &lt;&gt; Nil, child.FirstChild.Value, "")</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case "Attributes"</SourceLine>
   <SourceLine>d.Attributes_ = ParseAttributesNode(child)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case "ItemParams"</SourceLine>
   <SourceLine>d.Parameters = ParseParametersNode(child)</SourceLine>
   <SourceLine>d.ParameterString = If(child.FirstChild = Nil, "", child.FirstChild.Value)</SourceLine>
   <SourceLine>End Select</SourceLine>
   <SourceLine>Next i</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Compute the signature.</SourceLine>
   <SourceLine>d.Signature = d.Name + "(" + d.ParameterString + ")" + If(d.ReturnType = "", "", " As " + d.ReturnType)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Exclude this member?</SourceLine>
   <SourceLine>d.IsExcluded = XKProject.ShouldExcludeMember(d, mOptions)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Return d</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>node As XmlNode</ItemParams>
  <ItemResult>XKDelegate</ItemResult>
 </Method>
 <Method>
  <ItemName>ParseEnum</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>Parses an XML "Enumeration" node into an `XKEnum`.</CodeDescription>
  <PartID>1780318207</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function ParseEnum(node As XmlNode) As XKEnum</SourceLine>
   <SourceLine>/// Parses an XML "Enumeration" node into an `XKEnum`.</SourceLine>
   <SourceLine>///</SourceLine>
   <SourceLine>/// Assumes that `node` has already been validated to be an "Enumeration" node.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var e As New XKEnum</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var iLimit As Integer = node.ChildCount - 1</SourceLine>
   <SourceLine>For i As Integer = 0 To iLimit</SourceLine>
   <SourceLine>Var child As XmlNode = node.Child(i)</SourceLine>
   <SourceLine>Select Case child.Name</SourceLine>
   <SourceLine>Case "Attributes"</SourceLine>
   <SourceLine>e.Attributes_ = ParseAttributesNode(child)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case "BinaryEnum"</SourceLine>
   <SourceLine>e.IsBinary = If(Integer.FromString(child.FirstChild.Value) = 0, False, True)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case "CodeDescription"</SourceLine>
   <SourceLine>e.Description = If(child.FirstChild &lt;&gt; Nil, child.FirstChild.Value, "")</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case "ItemFlags"</SourceLine>
   <SourceLine>e.Scope = ScopeFromXMLInteger(Integer.FromString(child.FirstChild.Value))</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case "ItemName"</SourceLine>
   <SourceLine>e.Name = child.FirstChild.Value</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case "ItemSource"</SourceLine>
   <SourceLine>e.Members = ParseEnumMembers(child)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Select</SourceLine>
   <SourceLine>Next i</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// The signature is just the name.</SourceLine>
   <SourceLine>e.Signature = e.Name</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Exclude this member?</SourceLine>
   <SourceLine>e.IsExcluded = XKProject.ShouldExcludeMember(e, mOptions)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Return e</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>node As XmlNode</ItemParams>
  <ItemResult>XKEnum</ItemResult>
 </Method>
 <Method>
  <ItemName>ParseEnumMembers</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>Parses an XML enum's "ItemSource" node into an array of Pairs representing it's members.</CodeDescription>
  <PartID>477403135</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function ParseEnumMembers(node As XmlNode) As Pair()</SourceLine>
   <SourceLine>/// Parses an XML enum's "ItemSource" node into an array of Pairs representing it's members.</SourceLine>
   <SourceLine>///</SourceLine>
   <SourceLine>/// Assumes that `node` has already been validated to be an "ItemSource" node within an "Enum" node.</SourceLine>
   <SourceLine>/// Left = Member name, Right = Value (Integer).</SourceLine>
   <SourceLine>/// `Right` May be Nil if it's to be assigned automatically by the Xojo compiler.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var members() As Pair</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var iLimit As Integer = node.ChildCount - 1</SourceLine>
   <SourceLine>For i As Integer = 0 To iLimit</SourceLine>
   <SourceLine>Var child As XmlNode = node.Child(i)</SourceLine>
   <SourceLine>Select Case child.Name</SourceLine>
   <SourceLine>Case "SourceLine"</SourceLine>
   <SourceLine>If child.FirstChild = Nil Then Continue</SourceLine>
   <SourceLine>Var nameDefault() As String = child.FirstChild.Value.Split(" = ")</SourceLine>
   <SourceLine>If nameDefault.Count = 1 Then</SourceLine>
   <SourceLine>members.Add(nameDefault(0) : Nil)</SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine>members.Add(nameDefault(0) : nameDefault(1))</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>End Select</SourceLine>
   <SourceLine>Next i</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Return members</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>node As XmlNode</ItemParams>
  <ItemResult>Pair()</ItemResult>
 </Method>
 <Method>
  <ItemName>ParseEvent</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>Parses an XML "HookInstance" node into an `XKEvent`.</CodeDescription>
  <PartID>1360551935</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function ParseEvent(node As XmlNode) As XKEvent</SourceLine>
   <SourceLine>/// Parses an XML "HookInstance" node into an `XKEvent`.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var e As New XKEvent</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var iLimit As Integer = node.ChildCount - 1</SourceLine>
   <SourceLine>For i As Integer = 0 To iLimit</SourceLine>
   <SourceLine>Var child As XmlNode = node.Child(i)</SourceLine>
   <SourceLine>Select Case child.Name</SourceLine>
   <SourceLine>Case "ItemName"</SourceLine>
   <SourceLine>e.Name = child.FirstChild.Value</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case "ItemSource"</SourceLine>
   <SourceLine>// First use our helper to get the source lines within the event.</SourceLine>
   <SourceLine>e.Lines = ParseItemSourceNode(child)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Now we'll parse the first `SourceLine` node in `ItemSource` as it's the event's signature line.</SourceLine>
   <SourceLine>For a As Integer = 0 To child.ChildCount - 1</SourceLine>
   <SourceLine>Var itemSourceChild As XmlNode = child.Child(a)</SourceLine>
   <SourceLine>If itemSourceChild.Name = "SourceLine" And itemSourceChild.FirstChild &lt;&gt; Nil Then</SourceLine>
   <SourceLine>// Only the first source line is the declaration.</SourceLine>
   <SourceLine>Var sigLine As String = itemSourceChild.FirstChild.Value</SourceLine>
   <SourceLine>Var rx As New XKRegex(REGEX_EVENT_FUNCTION_SIG)</SourceLine>
   <SourceLine>If Not rx.Match(sigLine) Then</SourceLine>
   <SourceLine>rx = New XKRegex(REGEX_EVENT_SUB_SIG)</SourceLine>
   <SourceLine>If Not rx.Match(sigLine) Then</SourceLine>
   <SourceLine>Raise New XKException("Expected an event handler's signature line.")</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>If rx.NamedGroups.Lookup("params", "") &lt;&gt; "" Then</SourceLine>
   <SourceLine>Var params() As String = rx.NamedGroups.Value("params").StringValue.Split(", ")</SourceLine>
   <SourceLine>Var paramRx As New XKRegex(REGEX_PARAM)</SourceLine>
   <SourceLine>For Each param As String In params</SourceLine>
   <SourceLine>If Not paramRx.Match(param) Then</SourceLine>
   <SourceLine>Raise New XKException("Invalid parameter within an event handler signature.")</SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine>Var p As New XKParameter</SourceLine>
   <SourceLine>p.DefaultValue = paramRx.NamedGroups.Lookup("default", "")</SourceLine>
   <SourceLine>p.IsParamArray = If(paramRx.NamedGroups.Lookup("isParamArray", "") = "", False, True)</SourceLine>
   <SourceLine>p.Name = paramRx.NamedGroups.Lookup("name", "")</SourceLine>
   <SourceLine>p.IsArray = If(p.Name.IndexOf("(") = -1, False, True)</SourceLine>
   <SourceLine>p.Type = paramRx.NamedGroups.Lookup("type", "")</SourceLine>
   <SourceLine>e.Parameters.Add(p)</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>Next param</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>Exit</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>Next a</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case "CodeDescription"</SourceLine>
   <SourceLine>e.Description = If(child.FirstChild &lt;&gt; Nil, child.FirstChild.Value, "")</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Select</SourceLine>
   <SourceLine>Next i</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Compute the event's signature.</SourceLine>
   <SourceLine>e.Signature = ComputeEventSignature(e)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Exclude this member?</SourceLine>
   <SourceLine>e.IsExcluded = XKProject.ShouldExcludeMember(e, mOptions)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Return e</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>node As XmlNode</ItemParams>
  <ItemResult>XKEvent</ItemResult>
 </Method>
 <Method>
  <ItemName>ParseEventDefinition</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>Parses an XML "Hook" node into an `XKEventDefinition`.</CodeDescription>
  <PartID>469188607</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function ParseEventDefinition(node As XmlNode) As XKEventDefinition</SourceLine>
   <SourceLine>/// Parses an XML "Hook" node into an `XKEventDefinition`.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var ed As NEw XKEventDefinition</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var iLimit As Integer = node.ChildCount - 1</SourceLine>
   <SourceLine>For i As Integer = 0 To iLimit</SourceLine>
   <SourceLine>Var child As XmlNode = node.Child(i)</SourceLine>
   <SourceLine>Select Case child.Name</SourceLine>
   <SourceLine>Case "Attributes"</SourceLine>
   <SourceLine>ed.Attributes_ = ParseAttributesNode(child)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case "CodeDescription"</SourceLine>
   <SourceLine>ed.Description = If(child.FirstChild &lt;&gt; Nil, child.FirstChild.Value, "")</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case "ItemName"</SourceLine>
   <SourceLine>ed.Name = child.FirstChild.Value</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case "ItemParams"</SourceLine>
   <SourceLine>ed.Parameters = ParseParametersNode(child)</SourceLine>
   <SourceLine>ed.ParameterString = If(child.FirstChild = Nil, "", child.FirstChild.Value)</SourceLine>
   <SourceLine>Case "ItemResult"</SourceLine>
   <SourceLine>ed.ReturnType = If(child.FirstChild &lt;&gt; Nil, child.FirstChild.Value, "")</SourceLine>
   <SourceLine>End Select</SourceLine>
   <SourceLine>Next i</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Compute the signature.</SourceLine>
   <SourceLine>ed.Signature = ed.Name + "(" + ed.ParameterString + ")" + If(ed.ReturnType = "", "", " As " + ed.ReturnType)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Exclude this member?</SourceLine>
   <SourceLine>ed.IsExcluded = XKProject.ShouldExcludeMember(ed, mOptions)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Return ed</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>node As XmlNode</ItemParams>
  <ItemResult>XKEventDefinition</ItemResult>
 </Method>
 <Method>
  <ItemName>ParseGetterOrSetter</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>Parses a "GetAccessor" or "SetAccessor" XML node to an array of lines representing the code within a getter/setter of a computed property.</CodeDescription>
  <PartID>189130751</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function ParseGetterOrSetter(node As XmlNode) As String()</SourceLine>
   <SourceLine>/// Parses a "GetAccessor" or "SetAccessor" XML node to an array of lines representing the code within a </SourceLine>
   <SourceLine>/// getter/setter of a computed property.</SourceLine>
   <SourceLine>///</SourceLine>
   <SourceLine>/// Example:</SourceLine>
   <SourceLine>/// ```</SourceLine>
   <SourceLine>/// &lt;GetAccessor&gt;</SourceLine>
   <SourceLine>///  &lt;TextEncoding&gt;134217984&lt;/TextEncoding&gt;</SourceLine>
   <SourceLine>///  &lt;SourceLine&gt;Get&lt;/SourceLine&gt;</SourceLine>
   <SourceLine>///  &lt;SourceLine&gt;&lt;/SourceLine&gt;</SourceLine>
   <SourceLine>///  &lt;SourceLine&gt;End Get&lt;/SourceLine&gt;</SourceLine>
   <SourceLine>/// &lt;/GetAccessor&gt;</SourceLine>
   <SourceLine>/// ```</SourceLine>
   <SourceLine>/// I'm ignoring the text encoding because I haven't reverse engineered it yet!</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var lines() As String</SourceLine>
   <SourceLine>Var sourceLineCount As Integer = 0</SourceLine>
   <SourceLine>Var iLimit As Integer = node.ChildCount - 1</SourceLine>
   <SourceLine>For i As Integer = 0 To iLimit</SourceLine>
   <SourceLine>Var child As XmlNode = node.Child(i)</SourceLine>
   <SourceLine>Select Case child.Name</SourceLine>
   <SourceLine>Case "SourceLine"</SourceLine>
   <SourceLine>If sourceLineCount = 0 Then</SourceLine>
   <SourceLine>// The first line should be ignored.</SourceLine>
   <SourceLine>sourceLineCount = 1</SourceLine>
   <SourceLine>Continue</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Don't add the last line.</SourceLine>
   <SourceLine>If i &lt; iLimit Then</SourceLine>
   <SourceLine>If child.FirstChild = Nil Then</SourceLine>
   <SourceLine>lines.Add("")</SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine>lines.Add(child.FirstChild.Value)</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>End Select</SourceLine>
   <SourceLine>Next i</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Return lines</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>node As XmlNode</ItemParams>
  <ItemResult>String()</ItemResult>
 </Method>
 <Method>
  <ItemName>ParseItemSourceNode</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>Takes an "ItemSource" XML node and returns the lines of code, excluding the declaration and end lines.</CodeDescription>
  <PartID>2012905471</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function ParseItemSourceNode(node As XmlNode) As String()</SourceLine>
   <SourceLine>/// Takes an "ItemSource" XML node and returns the lines of code, excluding the declaration and end lines.</SourceLine>
   <SourceLine>///</SourceLine>
   <SourceLine>/// ```</SourceLine>
   <SourceLine>/// &lt;ItemSource&gt;</SourceLine>
   <SourceLine>///  &lt;TextEncoding&gt;134217984&lt;/TextEncoding&gt;</SourceLine>
   <SourceLine>///  &lt;SourceLine&gt;SIGNATURE&lt;/SourceLine&gt;</SourceLine>
   <SourceLine>///  &lt;SourceLine&gt;Code line 1&lt;/SourceLine&gt;</SourceLine>
   <SourceLine>///  &lt;SourceLine&gt;...&lt;/SourceLine&gt;</SourceLine>
   <SourceLine>///  &lt;SourceLine&gt;Code line n&lt;/SourceLine&gt;</SourceLine>
   <SourceLine>///  &lt;SourceLine&gt;END DECLARATION&lt;/SourceLine&gt;</SourceLine>
   <SourceLine>/// &lt;/ItemSource&gt;</SourceLine>
   <SourceLine>/// ```</SourceLine>
   <SourceLine>///</SourceLine>
   <SourceLine>/// I'm ignoring the text encoding because I haven't reverse engineered it yet!</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var lines() As String</SourceLine>
   <SourceLine>Var sourceLineCount As Integer = 0</SourceLine>
   <SourceLine>Var iLimit As Integer = node.ChildCount - 1</SourceLine>
   <SourceLine>For i As Integer = 0 To iLimit</SourceLine>
   <SourceLine>Var child As XmlNode = node.Child(i)</SourceLine>
   <SourceLine>Select Case child.Name</SourceLine>
   <SourceLine>Case "SourceLine"</SourceLine>
   <SourceLine>If sourceLineCount = 0 Then</SourceLine>
   <SourceLine>// The first line should be ignored.</SourceLine>
   <SourceLine>sourceLineCount = 1</SourceLine>
   <SourceLine>Continue</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Don't add the last line.</SourceLine>
   <SourceLine>If i &lt; iLimit Then</SourceLine>
   <SourceLine>If child.FirstChild = Nil Then</SourceLine>
   <SourceLine>lines.Add("")</SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine>lines.Add(child.FirstChild.Value)</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Select</SourceLine>
   <SourceLine>Next i</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Return lines</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>node As XmlNode</ItemParams>
  <ItemResult>String()</ItemResult>
 </Method>
 <Method>
  <ItemName>ParseMethod</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>Parses an XML "Method" node into an `XKMethod`.</CodeDescription>
  <PartID>450326527</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function ParseMethod(node As XmlNode) As XKMethod</SourceLine>
   <SourceLine>/// Parses an XML "Method" node into an `XKMethod`.</SourceLine>
   <SourceLine>///</SourceLine>
   <SourceLine>/// Assumes that `node` has already been validated to be a "Method" node.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var m As New XKMethod</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var iLimit As Integer = node.ChildCount - 1</SourceLine>
   <SourceLine>For i As Integer = 0 To iLimit</SourceLine>
   <SourceLine>Var child As XmlNode = node.Child(i)</SourceLine>
   <SourceLine>Select Case child.Name</SourceLine>
   <SourceLine>Case "ItemName"</SourceLine>
   <SourceLine>m.Name = child.FirstChild.Value</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case "ItemFlags"</SourceLine>
   <SourceLine>m.Scope = ScopeFromXMLInteger(Integer.FromString(child.FirstChild.Value))</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case "IsShared"</SourceLine>
   <SourceLine>m.IsShared = If(child.FirstChild.Value = "0", False, True)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case "CodeDescription"</SourceLine>
   <SourceLine>m.Description = If(child.FirstChild &lt;&gt; Nil, child.FirstChild.Value, "")</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case "ItemResult"</SourceLine>
   <SourceLine>m.ReturnType = If(child.FirstChild &lt;&gt; Nil, child.FirstChild.Value, "")</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case "ItemSource"</SourceLine>
   <SourceLine>m.Lines = ParseItemSourceNode(child)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case "Attributes"</SourceLine>
   <SourceLine>m.Attributes_ = ParseAttributesNode(child)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case "ItemParams"</SourceLine>
   <SourceLine>m.Parameters = ParseParametersNode(child)</SourceLine>
   <SourceLine>m.ParameterString = If(child.FirstChild = Nil, "", child.FirstChild.Value)</SourceLine>
   <SourceLine>End Select</SourceLine>
   <SourceLine>Next i</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Compute the signature.</SourceLine>
   <SourceLine>m.Signature = m.Name + "(" + m.ParameterString + ")" + If(m.ReturnType = "", "", " As " + m.ReturnType)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Exclude this member?</SourceLine>
   <SourceLine>m.IsExcluded = XKProject.ShouldExcludeMember(m, mOptions)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Return m</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>node As XmlNode</ItemParams>
  <ItemResult>XKMethod</ItemResult>
 </Method>
 <Method>
  <ItemName>ParseNote</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>Parses an XML "Note" node into an `XKNote`.</CodeDescription>
  <PartID>1976197119</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function ParseNote(node As XmlNode) As XKNote</SourceLine>
   <SourceLine>/// Parses an XML "Note" node into an `XKNote`.</SourceLine>
   <SourceLine>///</SourceLine>
   <SourceLine>/// Assumes that `node` has already been validated to be a "Note" node.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var note As New XKNote</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var iLimit As Integer = node.ChildCount - 1</SourceLine>
   <SourceLine>For i As Integer = 0 To iLimit</SourceLine>
   <SourceLine>Var child As XmlNode = node.Child(i)</SourceLine>
   <SourceLine>Select Case child.Name</SourceLine>
   <SourceLine>Case "ItemName"</SourceLine>
   <SourceLine>note.Name = child.FirstChild.Value</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case "CodeDescription"</SourceLine>
   <SourceLine>note.Description = If(child.FirstChild = Nil, "", child.FirstChild.Value)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case "ItemSource"</SourceLine>
   <SourceLine>Var noteLineCount As Integer = 0</SourceLine>
   <SourceLine>Var jLimit As Integer = child.ChildCount - 1</SourceLine>
   <SourceLine>For j As Integer = 0 To jLimit</SourceLine>
   <SourceLine>Var itemSourceChild As XmlNode = child.Child(j)</SourceLine>
   <SourceLine>Select Case itemSourceChild.Name</SourceLine>
   <SourceLine>Case "NoteLine"</SourceLine>
   <SourceLine>If noteLineCount = 0 Then</SourceLine>
   <SourceLine>// The first line should be ignored (it's the note's title again).</SourceLine>
   <SourceLine>noteLineCount = 1</SourceLine>
   <SourceLine>Continue</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>If itemSourceChild.FirstChild &lt;&gt; Nil Then</SourceLine>
   <SourceLine>note.Lines.Add(itemSourceChild.FirstChild.Value)</SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine>note.Lines.Add("")</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>End Select</SourceLine>
   <SourceLine>Next j</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Select</SourceLine>
   <SourceLine>Next i</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// The signature is just the name.</SourceLine>
   <SourceLine>note.Signature = note.Name</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Exclude this member?</SourceLine>
   <SourceLine>note.IsExcluded = XKProject.ShouldExcludeMember(note, mOptions)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Return note</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>node As XmlNode</ItemParams>
  <ItemResult>XKNote</ItemResult>
 </Method>
 <Method>
  <ItemName>ParseParametersNode</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>Takes an "ItemParams" XML node and returns the parameters (if any) as an array of XKParameters.</CodeDescription>
  <PartID>1218543615</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function ParseParametersNode(node As XmlNode) As XKParameter()</SourceLine>
   <SourceLine>/// Takes an "ItemParams" XML node and returns the parameters (if any) as an array of XKParameters.</SourceLine>
   <SourceLine>///</SourceLine>
   <SourceLine>/// If there are no parameters then ItemParams is empty. </SourceLine>
   <SourceLine>/// If there are parameters then the node contains the parameter string, e.g:</SourceLine>
   <SourceLine>/// `i As Integer, s As String = "Hello"`</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var result() As XKParameter</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>If node = Nil Or node.FirstChild = Nil Then Return result</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var params() As String = node.FirstChild.Value.Split(", ")</SourceLine>
   <SourceLine>Var paramRx As New XKRegex(REGEX_PARAM)</SourceLine>
   <SourceLine>For Each param As String In params</SourceLine>
   <SourceLine>If Not paramRx.Match(param) Then</SourceLine>
   <SourceLine>Raise New XKException("Invalid parameter within ""ItemParams"" node.")</SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine>Var p As New XKParameter</SourceLine>
   <SourceLine>p.DefaultValue = paramRx.NamedGroups.Lookup("default", "")</SourceLine>
   <SourceLine>p.IsParamArray = If(paramRx.NamedGroups.Lookup("isParamArray", "") = "", False, True)</SourceLine>
   <SourceLine>p.Name = paramRx.NamedGroups.Lookup("name", "")</SourceLine>
   <SourceLine>p.IsArray = If(p.Name.IndexOf("(") = -1, False, True)</SourceLine>
   <SourceLine>p.Type = paramRx.NamedGroups.Lookup("type", "")</SourceLine>
   <SourceLine>result.Add(p)</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>Next param</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Return result</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>node As XmlNode</ItemParams>
  <ItemResult>XKParameter()</ItemResult>
 </Method>
 <Method>
  <ItemName>ParsePropertyNote</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>Parses an "ItemSource" node within a property XML node. This may contain a note which is returned as an array of lines.</CodeDescription>
  <PartID>1626445823</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function ParsePropertyNote(node As XmlNode) As String()</SourceLine>
   <SourceLine>/// Parses an "ItemSource" node within a property XML node. This may contain a note which is returned as an</SourceLine>
   <SourceLine>/// array of lines.</SourceLine>
   <SourceLine>///</SourceLine>
   <SourceLine>/// ```</SourceLine>
   <SourceLine>/// &lt;ItemSource&gt;</SourceLine>
   <SourceLine>///  &lt;TextEncoding&gt;134217984&lt;/TextEncoding&gt;  &lt;--- Always present</SourceLine>
   <SourceLine>///   &lt;SourceLine&gt;Property PublicComputedPropWithNote As Integer&lt;/SourceLine&gt; &lt;---- Always present</SourceLine>
   <SourceLine>///   &lt;SourceLine&gt;Here is a note.&lt;/SourceLine&gt; &lt;--- optional `n` occurrences</SourceLine>
   <SourceLine>/// &lt;/ItemSource&gt;</SourceLine>
   <SourceLine>/// ```</SourceLine>
   <SourceLine>/// I'm ignoring the text encoding because I haven't reverse engineered it yet!</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var lines() As String</SourceLine>
   <SourceLine>Var sourceLineCount As Integer = 0</SourceLine>
   <SourceLine>Var iLimit As Integer = node.ChildCount - 1</SourceLine>
   <SourceLine>For i As Integer = 0 To iLimit</SourceLine>
   <SourceLine>Var child As XmlNode = node.Child(i)</SourceLine>
   <SourceLine>Select Case child.Name</SourceLine>
   <SourceLine>Case "SourceLine"</SourceLine>
   <SourceLine>If sourceLineCount = 0 Then</SourceLine>
   <SourceLine>// The first line should be ignored as it's the property declaration.</SourceLine>
   <SourceLine>sourceLineCount = 1</SourceLine>
   <SourceLine>Continue</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>If child.FirstChild &lt;&gt; Nil Then</SourceLine>
   <SourceLine>lines.Add(child.FirstChild.Value)</SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine>lines.Add("")</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>End Select</SourceLine>
   <SourceLine>Next i</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Return lines</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>node As XmlNode</ItemParams>
  <ItemResult>String()</ItemResult>
 </Method>
 <Method>
  <ItemName>ScopeFromXMLInteger</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>Returns the scope of an item from the integer value stored in an XML serialisation.</CodeDescription>
  <PartID>850382847</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function ScopeFromXMLInteger(xmlValue As Integer) As XojoKit.Scopes</SourceLine>
   <SourceLine>/// Returns the scope of an item from the integer value stored in an XML serialisation.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Select Case xmlValue</SourceLine>
   <SourceLine>Case 0</SourceLine>
   <SourceLine>Return XojoKit.Scopes.Public_</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case 1</SourceLine>
   <SourceLine>Return XojoKit.Scopes.Protected_</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case 33</SourceLine>
   <SourceLine>Return XojoKit.Scopes.Private_</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine>// This is lazy but for now we'll just assume this is a public item.</SourceLine>
   <SourceLine>Return XojoKit.Scopes.Public_</SourceLine>
   <SourceLine>End Select</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>xmlValue As Integer</ItemParams>
  <ItemResult>XojoKit.Scopes</ItemResult>
 </Method>
 <Method>
  <ItemName>ParseStructure</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>Parses an XML "Structure" node into a `XKStructure`.</CodeDescription>
  <PartID>1895835647</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function ParseStructure(node As XmlNode) As XKStructure</SourceLine>
   <SourceLine>/// Parses an XML "Structure" node into a `XKStructure`.</SourceLine>
   <SourceLine>///</SourceLine>
   <SourceLine>/// Assumes that `node` has already been validated to be a "Structure" node.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var s As New XKStructure</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var iLimit As Integer = node.ChildCount - 1</SourceLine>
   <SourceLine>For i As Integer = 0 To iLimit</SourceLine>
   <SourceLine>Var child As XmlNode = node.Child(i)</SourceLine>
   <SourceLine>Select Case child.Name</SourceLine>
   <SourceLine>Case "Attributes"</SourceLine>
   <SourceLine>s.Attributes_ = ParseAttributesNode(child)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case "CodeDescription"</SourceLine>
   <SourceLine>s.Description = If(child.FirstChild &lt;&gt; Nil, child.FirstChild.Value, "")</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case "ItemFlags"</SourceLine>
   <SourceLine>s.Scope = ScopeFromXMLInteger(Integer.FromString(child.FirstChild.Value))</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case "ItemName"</SourceLine>
   <SourceLine>s.Name = child.FirstChild.Value</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case "ItemSource"</SourceLine>
   <SourceLine>s.Fields = ParseStructureFields(child)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Select</SourceLine>
   <SourceLine>Next i</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// The signature is just the name.</SourceLine>
   <SourceLine>s.Signature = s.Name</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Exclude this member?</SourceLine>
   <SourceLine>s.IsExcluded = XKProject.ShouldExcludeMember(s, mOptions)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Return s</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>node As XmlNode</ItemParams>
  <ItemResult>XKStructure</ItemResult>
 </Method>
 <Method>
  <ItemName>ParseStructureFields</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>Parses an XML structure's "ItemSource" node into an array of XKStructureFields representing it's fields.</CodeDescription>
  <PartID>152535039</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function ParseStructureFields(node As XmlNode) As XKStructureField()</SourceLine>
   <SourceLine>/// Parses an XML structure's "ItemSource" node into an array of XKStructureFields representing it's fields.</SourceLine>
   <SourceLine>///</SourceLine>
   <SourceLine>/// Assumes that `node` has already been validated to be an "ItemSource" node within a "Structure" node.</SourceLine>
   <SourceLine>///</SourceLine>
   <SourceLine>/// ```</SourceLine>
   <SourceLine>///   &lt;ItemSource&gt;</SourceLine>
   <SourceLine>///    &lt;TextEncoding&gt;134217984&lt;/TextEncoding&gt;</SourceLine>
   <SourceLine>///    &lt;SourceLine&gt;Age As Integer&lt;/SourceLine&gt;</SourceLine>
   <SourceLine>///    &lt;SourceLine&gt;Data(100) As Byte&lt;/SourceLine&gt;</SourceLine>
   <SourceLine>///    &lt;SourceLine&gt;Name As String * 50&lt;/SourceLine&gt;</SourceLine>
   <SourceLine>///   &lt;/ItemSource&gt;</SourceLine>
   <SourceLine>/// ```</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var fields() As XKStructureField</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var iLimit As Integer = node.ChildCount - 1</SourceLine>
   <SourceLine>Var fieldIndex As Integer = -1</SourceLine>
   <SourceLine>For i As Integer = 0 To iLimit</SourceLine>
   <SourceLine>Var child As XmlNode = node.Child(i)</SourceLine>
   <SourceLine>Select Case child.Name</SourceLine>
   <SourceLine>Case "SourceLine"</SourceLine>
   <SourceLine>fieldIndex = fieldIndex + 1</SourceLine>
   <SourceLine>If child.FirstChild = Nil Then</SourceLine>
   <SourceLine>// This is a field with an empty declaration in the IDE. We will still add it as an</SourceLine>
   <SourceLine>// empty field although I suspect this is a broken implementation in the IDE.</SourceLine>
   <SourceLine>fields.Add(New XKStructureField(fieldIndex, "", ""))</SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine>Var nameType() As String = child.FirstChild.Value.Split(" As ")</SourceLine>
   <SourceLine>fields.Add(New XKStructureField(fieldIndex, nameType(0), nameType(1)))</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>End Select</SourceLine>
   <SourceLine>Next i</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Return fields</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>node As XmlNode</ItemParams>
  <ItemResult>XKStructureField()</ItemResult>
 </Method>
 <Method>
  <ItemName>ComputeEventSignature</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>Computes and returns the passed event's user-facing signature (less decorations like attributes, etc).</CodeDescription>
  <PartID>1278957567</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function ComputeEventSignature(e As XKEvent) As String</SourceLine>
   <SourceLine>/// Computes and returns the passed event's user-facing signature (less decorations like attributes, etc).</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var sig as String = e.Name + "("</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>For i As Integer = 0 To e.Parameters.LastIndex</SourceLine>
   <SourceLine>Var p As XKParameter = e.Parameters(i)</SourceLine>
   <SourceLine>sig = sig + p.ToString + If(i &lt; e.Parameters.LastIndex, ", ", "")</SourceLine>
   <SourceLine>Next i</SourceLine>
   <SourceLine>sig = sig + ")"</SourceLine>
   <SourceLine>If e.ReturnType &lt;&gt; "" Then</SourceLine>
   <SourceLine>sig = sig + " As " + e.ReturnType</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Return sig</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>e As XKEvent</ItemParams>
  <ItemResult>String</ItemResult>
 </Method>
 <Property>
  <ItemName>mOptions</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>The options to use when parsing items and members.</CodeDescription>
  <PartID>1071794175</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>mOptions As XKOptions</SourceLine>
   <SourceLine></SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <ItemDeclaration>mOptions As XKOptions</ItemDeclaration>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
 </Property>
 <ViewBehavior>
  <ViewProperty>
   <ObjName>Name</ObjName>
   <Visible>1</Visible>
   <PropertyGroup>ID</PropertyGroup>
   <ItemType>String</ItemType>
  </ViewProperty>
  <ViewProperty>
   <ObjName>Index</ObjName>
   <Visible>1</Visible>
   <PropertyGroup>ID</PropertyGroup>
   <PropertyValue>-2147483648</PropertyValue>
   <ItemType>Integer</ItemType>
  </ViewProperty>
  <ViewProperty>
   <ObjName>Super</ObjName>
   <Visible>1</Visible>
   <PropertyGroup>ID</PropertyGroup>
   <ItemType>String</ItemType>
  </ViewProperty>
  <ViewProperty>
   <ObjName>Left</ObjName>
   <Visible>1</Visible>
   <PropertyGroup>Position</PropertyGroup>
   <PropertyValue>0</PropertyValue>
   <ItemType>Integer</ItemType>
  </ViewProperty>
  <ViewProperty>
   <ObjName>Top</ObjName>
   <Visible>1</Visible>
   <PropertyGroup>Position</PropertyGroup>
   <PropertyValue>0</PropertyValue>
   <ItemType>Integer</ItemType>
  </ViewProperty>
 </ViewBehavior>
 <Constant>
  <ItemName>REGEX_EVENT_FUNCTION_SIG</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>The regex pattern for matching an event handler's function signature within an "ItemSource &gt; SourceLine" XML node.</CodeDescription>
  <PartID>560711679</PartID>
  <TextEncoding>134217984</TextEncoding>
  <ItemType>0</ItemType>
  <ItemDef>(?&lt;type&gt;Function)\s(?&lt;name&gt;[a-z0-9_]+)\((?P&lt;params&gt;.+)?\)(?:\sAs\s)(?P&lt;return&gt;.+)</ItemDef>
  <ItemFlags>33</ItemFlags>
 </Constant>
 <Constant>
  <ItemName>REGEX_EVENT_SUB_SIG</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>The regex pattern for matching an event handler's sub signature within an "ItemSource &gt; SourceLine" XML node.</CodeDescription>
  <PartID>878874623</PartID>
  <TextEncoding>134217984</TextEncoding>
  <ItemType>0</ItemType>
  <ItemDef>(?&lt;type&gt;Sub)\s(?&lt;name&gt;[a-z0-9_]+)\((?P&lt;params&gt;.+)?\)</ItemDef>
  <ItemFlags>33</ItemFlags>
 </Constant>
 <Constant>
  <ItemName>REGEX_PARAM</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>The regex to match a single parameter within a signature.</CodeDescription>
  <PartID>99684351</PartID>
  <TextEncoding>134217984</TextEncoding>
  <ItemType>0</ItemType>
  <ItemDef>(?P&lt;isParamArray&gt;ParamArray)?\s?(?P&lt;name&gt;[a-z0-9_\.]+(?:\(.*\))?)\sAs\s(?P&lt;type&gt;[a-z0-9_\.]+)(?:\s=\s)?(?P&lt;default&gt;[a-z0-9._"\-\s]+)?</ItemDef>
  <ItemFlags>33</ItemFlags>
 </Constant>
</block>
</RBProject>
