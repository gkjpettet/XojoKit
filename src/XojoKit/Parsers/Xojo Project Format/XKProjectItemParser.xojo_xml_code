<?xml version="1.0" encoding="UTF-8"?>
<RBProject version="2022r1.1" FormatVersion="2" MinIDEVersion="20210300">
<block type="Module" ID="708849663">
 <ObjName>XKProjectItemParser</ObjName>
 <ObjContainerID>1057513471</ObjContainerID>
 <IsClass>1</IsClass>
 <Interfaces>XKItemParser</Interfaces>
 <ItemFlags>1</ItemFlags>
 <IsInterface>0</IsInterface>
 <Compatibility></Compatibility>
 <Method>
  <ItemName>Parse</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>Parses the contents of a file into its constituent methods, properties, events and notes.</CodeDescription>
  <PartID>1630775295</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Sub Parse(ByRef item As XKItem, options As XKOptions)</SourceLine>
   <SourceLine>/// Parses the contents of an item into its constituent methods, properties, events and notes.</SourceLine>
   <SourceLine>///</SourceLine>
   <SourceLine>/// Part of the XKItemParser interface.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Keep a reference to the parsing options.</SourceLine>
   <SourceLine>mOptions = options</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Default to this item being a class.</SourceLine>
   <SourceLine>item.Type = XojoKit.ItemTypes.Class_</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var tin As TextInputStream</SourceLine>
   <SourceLine>Var contents As String</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Try</SourceLine>
   <SourceLine>tin = TextInputStream.Open(item.File)</SourceLine>
   <SourceLine>contents = tin.ReadAll</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Catch e</SourceLine>
   <SourceLine>Raise New XKException("Unable to open file for reading `" + item.Path + "`.")</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Finally</SourceLine>
   <SourceLine>tin.Close</SourceLine>
   <SourceLine>End Try</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>contents = contents.ReplaceLineEndings(EndOfLine.UNIX)</SourceLine>
   <SourceLine>Var lines() As String = contents.Split(EndOfLine.UNIX)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var line As String</SourceLine>
   <SourceLine>For i As Integer = 0 To lines.LastIndex</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Skip lines that don't start with `#tag`.</SourceLine>
   <SourceLine>line = lines(i).Trim</SourceLine>
   <SourceLine>If line.IsEmpty Then Continue</SourceLine>
   <SourceLine>If Not line.BeginsWith("#tag") Then Continue</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Parse the tag.</SourceLine>
   <SourceLine>Var tag As New XKProjectItemTag(line)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Select Case tag.TagType</SourceLine>
   <SourceLine>Case "Class"</SourceLine>
   <SourceLine>ParseClassTag(item, lines, i)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case "Module"</SourceLine>
   <SourceLine>ParseModuleTag(item, lines, i)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case "Interface"</SourceLine>
   <SourceLine>ParseInterfaceTag(item, lines, i)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case "Property"</SourceLine>
   <SourceLine>item.Properties.Add(ParseProperty(tag, lines, i))</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case "ComputedProperty"</SourceLine>
   <SourceLine>item.Properties.Add(ParseComputedProperty(tag, lines, i))</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case "Method"</SourceLine>
   <SourceLine>item.Methods.Add(ParseMethod(tag, lines, i))</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case "DelegateDeclaration"</SourceLine>
   <SourceLine>item.Delegates.Add(ParseDelegate(tag, lines, i))</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case "Event"</SourceLine>
   <SourceLine>// This is an event that has been implemented by a class (NOT an event definition).</SourceLine>
   <SourceLine>item.Events.Add(ParseEvent(tag, lines, i))</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case "Hook"</SourceLine>
   <SourceLine>// This is an event definition.</SourceLine>
   <SourceLine>item.EventDefinitions.Add(ParseEventDefinition(tag, lines, i))</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case "Enum"</SourceLine>
   <SourceLine>item.Enums.Add(ParseEnum(tag, lines, i))</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case "Note"</SourceLine>
   <SourceLine>item.Notes.Add(ParseNote(tag, lines, i))</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case "Constant"</SourceLine>
   <SourceLine>item.Constants.Add(ParseConstant(tag, lines, i))</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case "Structure"</SourceLine>
   <SourceLine>item.Structures.Add(ParseStructure(tag, lines, i))</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Select</SourceLine>
   <SourceLine>Next i</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Sub</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>ByRef item As XKItem, options As XKOptions</ItemParams>
  <ItemResult></ItemResult>
 </Method>
 <Method>
  <ItemName>ParseClassTag</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>Parses a Class tag. Mutates `i`. May raise a `XodocException`.</CodeDescription>
  <PartID>701921279</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Sub ParseClassTag(ByRef item As XKItem, lines() As String, ByRef i As Integer)</SourceLine>
   <SourceLine>/// Parses a Class tag. Mutates `i`. May raise a `XKException`.</SourceLine>
   <SourceLine>///</SourceLine>
   <SourceLine>/// Assumes `lines` is the contents of `file`.</SourceLine>
   <SourceLine>/// Assumes `i` is the index in `lines` of a "#tag Class" line.</SourceLine>
   <SourceLine>/// Sets the required properties on `item` for this class.</SourceLine>
   <SourceLine>///</SourceLine>
   <SourceLine>/// #tag Class format:</SourceLine>
   <SourceLine>/// ```</SourceLine>
   <SourceLine>/// #tag Class</SourceLine>
   <SourceLine>/// (Attributes LPAREN AttributeKeyValue (COMMA AttributeKeyValue)* RPAREN)? Scope CLASS CLASS_NAME</SourceLine>
   <SourceLine>/// (INHERITS SUPERCLASS)?</SourceLine>
   <SourceLine>/// (IMPLEMENTS FQN (COMMA FQN)*)?</SourceLine>
   <SourceLine>/// ...</SourceLine>
   <SourceLine>/// #tag EndClass</SourceLine>
   <SourceLine>/// </SourceLine>
   <SourceLine>/// ```</SourceLine>
   <SourceLine>///</SourceLine>
   <SourceLine>/// AttributeKeyValue → ATTRIBUTE (EQUAL VALUE)?</SourceLine>
   <SourceLine>/// Scope             → PROTECTED | PRIVATE</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// The item must be a class.</SourceLine>
   <SourceLine>item.Type = XojoKit.ItemTypes.Class_</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Sanity check.</SourceLine>
   <SourceLine>If i &gt;= lines.LastIndex Then</SourceLine>
   <SourceLine>Raise New XKException("Expected a scope / attributes line after the Class tag. " + _</SourceLine>
   <SourceLine>"Instead the parser ran out of lines.")</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// ===============</SourceLine>
   <SourceLine>// SCOPE LINE</SourceLine>
   <SourceLine>// ===============</SourceLine>
   <SourceLine>// The next line must be the scope +/- attributes line.</SourceLine>
   <SourceLine>Var scopeLine As String = lines(i + 1).Trim</SourceLine>
   <SourceLine>i = i + 1</SourceLine>
   <SourceLine>Var hasAttributes As Boolean = False</SourceLine>
   <SourceLine>If scopeLine.BeginsWith("Attributes") Then</SourceLine>
   <SourceLine>hasAttributes = True</SourceLine>
   <SourceLine>ElseIf scopeLine.BeginsWith("Protected") = False And scopeLine.BeginsWith("Private") = False Then</SourceLine>
   <SourceLine>Raise New XKException("Expected a scope / attributes line after the Class tag.")</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// ===============</SourceLine>
   <SourceLine>// INHERITS LINE</SourceLine>
   <SourceLine>// ===============</SourceLine>
   <SourceLine>// Get the optional "inherits" line.</SourceLine>
   <SourceLine>Var inheritsLine As String</SourceLine>
   <SourceLine>If i &lt; lines.LastIndex Then</SourceLine>
   <SourceLine>inheritsLine = lines(i + 1).Trim</SourceLine>
   <SourceLine>If inheritsLine.BeginsWith("Inherits") Then</SourceLine>
   <SourceLine>i = i + 1</SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine>inheritsLine = ""</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// ===============</SourceLine>
   <SourceLine>// IMPLEMENTS LINE</SourceLine>
   <SourceLine>// ===============</SourceLine>
   <SourceLine>// Get the optional "implements" line.</SourceLine>
   <SourceLine>Var implementsLine As String</SourceLine>
   <SourceLine>If i &lt; lines.LastIndex Then</SourceLine>
   <SourceLine>implementsLine = lines(i + 1).Trim</SourceLine>
   <SourceLine>If implementsLine.BeginsWith("Implements") Then</SourceLine>
   <SourceLine>i = i + 1</SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine>implementsLine = ""</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Optional attributes?</SourceLine>
   <SourceLine>If hasAttributes Then</SourceLine>
   <SourceLine>Var attrString As String = scopeLine.Left(scopeLine.IndexOf(")") + 1)</SourceLine>
   <SourceLine>scopeLine = scopeLine.Replace(attrString, "").Trim</SourceLine>
   <SourceLine>attrString = attrString.Replace("Attributes (", "")</SourceLine>
   <SourceLine>attrString = attrString.Replace(")", "")</SourceLine>
   <SourceLine>attrString = attrString.Trim</SourceLine>
   <SourceLine>Var attributeKeyValues() As String = attrString.Split(", ")</SourceLine>
   <SourceLine>For Each keyValue As String In attributeKeyValues</SourceLine>
   <SourceLine>Var kv() As String = keyValue.Split(" = ")</SourceLine>
   <SourceLine>If kv.Count &gt; 1 Then</SourceLine>
   <SourceLine>item.Attributes_.Add(kv(0).Trim : kv(1).Trim)</SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine>item.Attributes_.Add(kv(0).Trim : "")</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>Next keyValue</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Scope.</SourceLine>
   <SourceLine>If scopeLine.BeginsWith("Private") Then</SourceLine>
   <SourceLine>item.Scope = XojoKit.Scopes.Private_</SourceLine>
   <SourceLine>ElseIf scopeLine.BeginsWith("Protected") Then</SourceLine>
   <SourceLine>item.Scope = XojoKit.Scopes.Protected_</SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine>item.Scope = XojoKit.Scopes.Public_</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Optional superclass?</SourceLine>
   <SourceLine>If Not inheritsLine.IsEmpty Then</SourceLine>
   <SourceLine>item.Superclass = inheritsLine.Replace("Inherits", "").Trim</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Optional interfaces?</SourceLine>
   <SourceLine>If Not implementsLine.IsEmpty Then</SourceLine>
   <SourceLine>implementsLine = implementsLine.Replace("Implements", "").Trim</SourceLine>
   <SourceLine>Var interfaces() As String = implementsLine.Split(",")</SourceLine>
   <SourceLine>For Each inter As String In interfaces</SourceLine>
   <SourceLine>item.ImplementedInterfaces.Add(inter.Trim)</SourceLine>
   <SourceLine>Next inter</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>End Sub</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>ByRef item As XKItem, lines() As String, ByRef i As Integer</ItemParams>
  <ItemResult></ItemResult>
 </Method>
 <Method>
  <ItemName>ParseComputedProperty</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>Parses a computed property from `lines` starting at `i` using the data within `tag`.</CodeDescription>
  <PartID>736511999</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function ParseComputedProperty(tag As XKProjectItemTag, lines() As String, ByRef i As Integer) As XKProperty</SourceLine>
   <SourceLine>/// Parses a computed property from `lines` starting at `i` using the data within `tag`. </SourceLine>
   <SourceLine>///</SourceLine>
   <SourceLine>/// Assumes `lines(i)` is the "#tag ComputedProperty" line which has been parsed into `tag`.</SourceLine>
   <SourceLine>/// Format:</SourceLine>
   <SourceLine>/// ```</SourceLine>
   <SourceLine>/// #TAG COMPUTED_PROPERTY TagProperties</SourceLine>
   <SourceLine>///   Getter?</SourceLine>
   <SourceLine>///   Setter?</SourceLine>
   <SourceLine>///   (Shared)? (Scope)? NAME AS TYPE</SourceLine>
   <SourceLine>/// #TAG END_COMPUTED_PROPERTY</SourceLine>
   <SourceLine>///</SourceLine>
   <SourceLine>/// TagProperties → (FLAGS EQUAL HexLiteral)?, DESCRIPTION EQUAL Base64String</SourceLine>
   <SourceLine>/// Scope         → PUBLIC | GLOBAL | PROTECTED | PRIVATE</SourceLine>
   <SourceLine>/// Getter        → #TAG GETTER EOL GET EOL (CODE_LINE)* END GET #TAG END_GETTER</SourceLine>
   <SourceLine>/// Setter        → #TAG SETTER EOL SET EOL (CODE_LINE)* END SET #TAG END_SETTER</SourceLine>
   <SourceLine>/// ```</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Sanity check.</SourceLine>
   <SourceLine>If i &gt;= lines.LastIndex Then</SourceLine>
   <SourceLine>Raise New XKException("Expected a computed property declaration line but instead the " + _</SourceLine>
   <SourceLine>"parser reached the end.")</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var cp As New XKProperty(XojoKit.MemberTypes.ComputedProperty_)</SourceLine>
   <SourceLine>cp.IsComputed = True</SourceLine>
   <SourceLine>cp.Description = tag.Description</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Advance past the #tag "ComputedProperty" line.</SourceLine>
   <SourceLine>i = i + 1</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Optional note?</SourceLine>
   <SourceLine>If lines(i).Trim.BeginsWith("#tag Note") Then</SourceLine>
   <SourceLine>i = i + 1</SourceLine>
   <SourceLine>While i &lt;= lines.LastIndex</SourceLine>
   <SourceLine>Var line As String = lines(i).Trim</SourceLine>
   <SourceLine>If line = "#tag EndNote" Then</SourceLine>
   <SourceLine>i = i + 1</SourceLine>
   <SourceLine>Exit</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>cp.NoteLines.Add(line)</SourceLine>
   <SourceLine>i = i + 1</SourceLine>
   <SourceLine>Wend</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Optional getter?</SourceLine>
   <SourceLine>If lines(i).Trim.BeginsWith("#tag Getter") Then</SourceLine>
   <SourceLine>cp.GetterLines = ParseGetter(lines, i)</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Optional setter?</SourceLine>
   <SourceLine>If lines(i).Trim.BeginsWith("#tag Setter") Then</SourceLine>
   <SourceLine>cp.SetterLines = ParseSetter(lines, i)</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Get the declaration and advance `i` past it.</SourceLine>
   <SourceLine>Var decLine As String = lines(i).Trim</SourceLine>
   <SourceLine>i = i + 1</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Get the scope.</SourceLine>
   <SourceLine>If decLine.IndexOf("Private ") &lt;&gt; - 1 Then</SourceLine>
   <SourceLine>cp.Scope = XojoKit.Scopes.Private_</SourceLine>
   <SourceLine>decLine = decLine.Replace("Private ", "").Trim</SourceLine>
   <SourceLine>ElseIf decLine.IndexOf("Protected ") &lt;&gt; -1 Then</SourceLine>
   <SourceLine>cp.Scope = XojoKit.Scopes.Protected_</SourceLine>
   <SourceLine>decLine = decLine.Replace("Protected ", "").Trim</SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine>cp.Scope = XojoKit.Scopes.Public_</SourceLine>
   <SourceLine>decLine = decLine.Trim</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Shared?</SourceLine>
   <SourceLine>If decLine.IndexOf("Shared ") &lt;&gt; -1 Then</SourceLine>
   <SourceLine>cp.IsShared = True</SourceLine>
   <SourceLine>decLine = decLine.Replace("Shared ", "").Trim</SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine>cp.IsShared = False</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Get the constant name and type.</SourceLine>
   <SourceLine>Var nameType() As String = decLine.Split(" As ")</SourceLine>
   <SourceLine>cp.Name = nameType(0).Trim</SourceLine>
   <SourceLine>cp.Type = nameType(1).Trim</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// The signature is just the name.</SourceLine>
   <SourceLine>cp.Signature = cp.Name</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Exclude this member?</SourceLine>
   <SourceLine>cp.IsExcluded = XKProject.ShouldExcludeMember(cp, mOptions)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Return cp</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>tag As XKProjectItemTag, lines() As String, ByRef i As Integer</ItemParams>
  <ItemResult>XKProperty</ItemResult>
 </Method>
 <Method>
  <ItemName>ParseConstant</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>Parses a Xojo constant from `lines` starting at `i` using the data within `tag`</CodeDescription>
  <PartID>1802995711</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function ParseConstant(tag As XKProjectItemTag, lines() As String, ByRef i As Integer) As XKConstant</SourceLine>
   <SourceLine>/// Parses a Xojo constant from `lines` starting at `i` using the data within `tag`</SourceLine>
   <SourceLine>///</SourceLine>
   <SourceLine>/// Assumes `lines(i)` is the "#tag Constant" line which has been parsed into `tag`.</SourceLine>
   <SourceLine>/// Format:</SourceLine>
   <SourceLine>/// ```</SourceLine>
   <SourceLine>/// #TAG CONSTANT TagProperties</SourceLine>
   <SourceLine>///   (#TAG INSTANCE InstanceProperties)*</SourceLine>
   <SourceLine>/// #TAG ENDCONSTANT</SourceLine>
   <SourceLine>///</SourceLine>
   <SourceLine>/// TagProperties      → NAME EQUAL IDENTIFIER, TYPE EQUAL Literal, DYNAMIC EQUAL Boolean, </SourceLine>
   <SourceLine>///                      (FLAGS EQUAL HexLiteral)?, DESCRIPTION EQUAL Base64String, SCOPE EQUAL ScopeString, </SourceLine>
   <SourceLine>///                      DEFAULT EQUAL \"Literal"</SourceLine>
   <SourceLine>/// Scope              → PUBLIC | GLOBAL | PROTECTED | PRIVATE</SourceLine>
   <SourceLine>/// InstanceProperties → PLATFORM = String, LANGUAGE EQUAL String, DEFINITION EQUAL \"Literal"</SourceLine>
   <SourceLine>/// ```</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Sanity check.</SourceLine>
   <SourceLine>If i &gt;= lines.LastIndex Then</SourceLine>
   <SourceLine>Raise New XKException("Expected a constant declaration line but instead the parser reached the end.")</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var con As New XKConstant</SourceLine>
   <SourceLine>con.Name = tag.Name</SourceLine>
   <SourceLine>con.Attributes_ = tag.Attributes_</SourceLine>
   <SourceLine>con.DefaultValue = tag.Default</SourceLine>
   <SourceLine>con.IsDynamic = tag.IsDynamic</SourceLine>
   <SourceLine>con.Scope = tag.Scope</SourceLine>
   <SourceLine>con.Type = tag.Type</SourceLine>
   <SourceLine>con.Description = tag.Description</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Advance past the #Tag Constant line.</SourceLine>
   <SourceLine>i = i + 1</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Variants?</SourceLine>
   <SourceLine>While i &lt;= lines.LastIndex</SourceLine>
   <SourceLine>Var line As String = lines(i).Trim</SourceLine>
   <SourceLine>If line.BeginsWith("#tag EndConstant") Then</SourceLine>
   <SourceLine>Exit</SourceLine>
   <SourceLine>ElseIf line.BeginsWith("#Tag Instance") Then</SourceLine>
   <SourceLine>con.Variants.Add(ParseConstantVariant(lines(i)))</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>i = i + 1</SourceLine>
   <SourceLine>Wend</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// The signature is just the name.</SourceLine>
   <SourceLine>con.Signature = con.Name</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Exclude this member?</SourceLine>
   <SourceLine>con.IsExcluded = XKProject.ShouldExcludeMember(con, mOptions)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Return con</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>tag As XKProjectItemTag, lines() As String, ByRef i As Integer</ItemParams>
  <ItemResult>XKConstant</ItemResult>
 </Method>
 <Method>
  <ItemName>ParseConstantVariant</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>Parses a constant variant from `line`.</CodeDescription>
  <PartID>590196735</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function ParseConstantVariant(line As String) As XKConstantVariant</SourceLine>
   <SourceLine>/// Parses a constant variant from `line`.</SourceLine>
   <SourceLine>///</SourceLine>
   <SourceLine>/// Assumes `line` is a "#Tag Instance" line within a `#tag Constant...#tag EndConstant` construct.</SourceLine>
   <SourceLine>/// Format:</SourceLine>
   <SourceLine>/// ```</SourceLine>
   <SourceLine>/// #Tag Instance, Platform = Mac OS, Language = Default, Definition  = \"&amp;h0A"</SourceLine>
   <SourceLine>/// ```</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>line = line.Trim</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Sanity check.</SourceLine>
   <SourceLine>If Not line.BeginsWith("#Tag Instance") Then</SourceLine>
   <SourceLine>Raise New XKException("Expected a `#Tag Instance` line. Instead got `" + line + "`.")</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var cv As New XKConstantVariant</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Remove the `#Tag Instance` prefix.</SourceLine>
   <SourceLine>line = line.Replace("#Tag Instance", "").Trim</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Get the (non-empty) parts.</SourceLine>
   <SourceLine>Var parts() As String = line.Split(",")</SourceLine>
   <SourceLine>For i As Integer = parts.LastIndex DownTo 0</SourceLine>
   <SourceLine>parts(i) = parts(i).Trim</SourceLine>
   <SourceLine>If parts(i).IsEmpty Then parts.RemoveAt(i)</SourceLine>
   <SourceLine>Next i</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>For Each part As String In parts</SourceLine>
   <SourceLine>Var keyValue() As String = part.Split(" = ")</SourceLine>
   <SourceLine>Var key As String = keyValue(0).Trim</SourceLine>
   <SourceLine>Var value As String = keyValue(1)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Select Case key</SourceLine>
   <SourceLine>Case "Platform"</SourceLine>
   <SourceLine>cv.Platform = value</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case "Language"</SourceLine>
   <SourceLine>cv.Language = value</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Case "Definition"</SourceLine>
   <SourceLine>// The value is a string prefixed with `\` and flanked with "".</SourceLine>
   <SourceLine>If value.Left(2) = "\""" Then</SourceLine>
   <SourceLine>value = value.Middle(2, value.Length - 3)</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>cv.Value = value</SourceLine>
   <SourceLine>End Select</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Next part</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Return cv</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>line As String</ItemParams>
  <ItemResult>XKConstantVariant</ItemResult>
 </Method>
 <Method>
  <ItemName>ParseDelegate</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>Parses a Xojo delegate from `lines` starting at `i` using the data within `tag`.</CodeDescription>
  <PartID>1491460095</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function ParseDelegate(tag As XKProjectItemTag, lines() As String, ByRef i As Integer) As XKDelegate</SourceLine>
   <SourceLine>/// Parses a Xojo delegate from `lines` starting at `i` using the data within `tag`.</SourceLine>
   <SourceLine>///</SourceLine>
   <SourceLine>/// Assumes `lines(i)` is the "#tag DelegateDeclaration" line which has been parsed into `tag`.</SourceLine>
   <SourceLine>/// Format:</SourceLine>
   <SourceLine>/// ```</SourceLine>
   <SourceLine>/// Attributes? Scope? (FUNCTION | SUB) NAME LPAREN (Param (COMMA Param)*)? RPAREN (AS TYPE)?</SourceLine>
   <SourceLine>/// Attributes → ATTRIBUTES( KeyValue (COMMA KeyValue)* )</SourceLine>
   <SourceLine>/// Scope → PUBLIC | GLOBAL | PROTECTED | PRIVATE</SourceLine>
   <SourceLine>/// Param → PARAM_ARRAY? NAME(LPAREN RPAREN)? AS TYPE (EQUAL VALUE)?</SourceLine>
   <SourceLine>/// ```</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Sanity check.</SourceLine>
   <SourceLine>If i &gt;= lines.LastIndex Then</SourceLine>
   <SourceLine>Raise New XKException("Expected a delegate signature line but instead the parser reached the end.")</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Advance to the signature line.</SourceLine>
   <SourceLine>i = i + 1</SourceLine>
   <SourceLine>Var sigLine As String = lines(i)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Search the signature line.</SourceLine>
   <SourceLine>Var rx As New XKRegex(REGEX_FUNCTION_SIG)</SourceLine>
   <SourceLine>If Not rx.Match(sigLine) Then</SourceLine>
   <SourceLine>rx = New XKRegex(REGEX_SUB_SIG)</SourceLine>
   <SourceLine>If Not rx.Match(sigLine) Then</SourceLine>
   <SourceLine>Raise New XKException("Expected a delegate signature line.")</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Advance past the signature line index.</SourceLine>
   <SourceLine>i = i + 1</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var d As New XKDelegate</SourceLine>
   <SourceLine>d.Name = rx.NamedGroups.Lookup("name", "")</SourceLine>
   <SourceLine>d.ReturnType = rx.NamedGroups.Lookup("return", "")</SourceLine>
   <SourceLine>d.Scope = XojoKit.ScopeFromString(rx.NamedGroups.Lookup("scope", ""))</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>If rx.NamedGroups.Lookup("Attributes", "") &lt;&gt; "" Then</SourceLine>
   <SourceLine>// Remove "Attributes (" and the trailing ")".</SourceLine>
   <SourceLine>Var attValue As String = rx.NamedGroups.Value("Attributes")</SourceLine>
   <SourceLine>attValue = attValue.Replace("Attributes( ", "").Replace(")", "").Trim</SourceLine>
   <SourceLine>Var attPairs() As String = attValue.Split(", ")</SourceLine>
   <SourceLine>For Each attPair As String In attPairs</SourceLine>
   <SourceLine>Var nameValue() As String = attPair.Split(" = ")</SourceLine>
   <SourceLine>If nameValue.Count = 1 Then</SourceLine>
   <SourceLine>d.Attributes_.Add(nameValue(0) : "")</SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine>d.Attributes_.Add(nameValue(0) : nameValue(1))</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>Next attPair</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>If rx.NamedGroups.Lookup("params", "") &lt;&gt; "" Then</SourceLine>
   <SourceLine>Var params() As String = rx.NamedGroups.Value("params").StringValue.Split(", ")</SourceLine>
   <SourceLine>Var paramRx As New XKRegex(REGEX_PARAM)</SourceLine>
   <SourceLine>For Each param As String In params</SourceLine>
   <SourceLine>If Not paramRx.Match(param) Then</SourceLine>
   <SourceLine>Raise New XKException("Invalid parameter within a delegate signature.")</SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine>Var p As New XKParameter</SourceLine>
   <SourceLine>p.DefaultValue = paramRx.NamedGroups.Lookup("default", "")</SourceLine>
   <SourceLine>p.IsParamArray = If(paramRx.NamedGroups.Lookup("isParamArray", "") = "", False, True)</SourceLine>
   <SourceLine>p.Name = paramRx.NamedGroups.Lookup("name", "")</SourceLine>
   <SourceLine>p.IsArray = If(p.Name.IndexOf("(") = -1, False, True)</SourceLine>
   <SourceLine>p.Type = paramRx.NamedGroups.Lookup("type", "")</SourceLine>
   <SourceLine>d.Parameters.Add(p)</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>Next param</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>d.Description = tag.Description</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Compute the delegate's signature and parameter string.</SourceLine>
   <SourceLine>ComputeDelegateSignatureAndParameterString(d)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Exclude this member?</SourceLine>
   <SourceLine>d.IsExcluded = XKProject.ShouldExcludeMember(d, mOptions)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Return d</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>tag As XKProjectItemTag, lines() As String, ByRef i As Integer</ItemParams>
  <ItemResult>XKDelegate</ItemResult>
 </Method>
 <Method>
  <ItemName>ParseEnum</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>Parses a Xojo enumeration from `lines` starting at `i` using the data within `tag`.</CodeDescription>
  <PartID>326062079</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function ParseEnum(tag As XKProjectItemTag, lines() As String, ByRef i As Integer) As XKEnum</SourceLine>
   <SourceLine>/// Parses a Xojo enumeration from `lines` starting at `i` using the data within `tag`.</SourceLine>
   <SourceLine>///</SourceLine>
   <SourceLine>/// Assumes `lines(i)` is the "#tag Enum" line which has been parsed into `tag`.</SourceLine>
   <SourceLine>/// Format:</SourceLine>
   <SourceLine>/// ```</SourceLine>
   <SourceLine>/// #TAG ENUM TagProperties</SourceLine>
   <SourceLine>/// (Member)+</SourceLine>
   <SourceLine>/// #TAG ENDENUM</SourceLine>
   <SourceLine>///</SourceLine>
   <SourceLine>/// TagProperties → NAME EQUAL IDENTIFIER, TYPE EQUAL Literal,</SourceLine>
   <SourceLine>///                 (FLAGS EQUAL HexLiteral)?, DESCRIPTION EQUAL Base64String, (BINARY = Boolean)?</SourceLine>
   <SourceLine>/// Member        → NAME (EQUAL VALUE)?</SourceLine>
   <SourceLine>/// ```</SourceLine>
   <SourceLine>/// </SourceLine>
   <SourceLine>/// The scope of an enum is defined by it's `Flags` value.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Sanity check.</SourceLine>
   <SourceLine>If i &gt;= lines.LastIndex Then</SourceLine>
   <SourceLine>Raise New XKException("Expected an enumeration declaration line but instead the parser reached the end.")</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var e As New XKEnum</SourceLine>
   <SourceLine>e.Attributes_ = tag.Attributes_</SourceLine>
   <SourceLine>e.Name = tag.Name</SourceLine>
   <SourceLine>e.IsBinary = tag.IsBinary</SourceLine>
   <SourceLine>e.Description = tag.Description</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Advance past the #Tag Enum line.</SourceLine>
   <SourceLine>i = i + 1</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Determine scope.</SourceLine>
   <SourceLine>If tag.Flags = "" Or Not tag.Flags.BeginsWith("&amp;h") Then</SourceLine>
   <SourceLine>e.Scope = XojoKit.Scopes.Public_</SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine>Var flagValue As Integer = Integer.FromHex(tag.Flags.TrimLeft("&amp;h"))</SourceLine>
   <SourceLine>Select Case flagValue</SourceLine>
   <SourceLine>Case 0</SourceLine>
   <SourceLine>e.Scope = XojoKit.Scopes.Public_</SourceLine>
   <SourceLine>Case 1</SourceLine>
   <SourceLine>e.Scope = XojoKit.Scopes.Protected_</SourceLine>
   <SourceLine>Case &amp;h21</SourceLine>
   <SourceLine>e.Scope = XojoKit.Scopes.Private_</SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine>Raise New XKException("Unknown enumeration flag value.")</SourceLine>
   <SourceLine>End Select</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Get the members.</SourceLine>
   <SourceLine>While i &lt;= lines.LastIndex</SourceLine>
   <SourceLine>Var line As String = lines(i).Trim</SourceLine>
   <SourceLine>If line.BeginsWith("#tag EndEnum") Then</SourceLine>
   <SourceLine>Exit</SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine>If line.IndexOf("=") = -1 Then</SourceLine>
   <SourceLine>e.Members.Add(line : Nil)</SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine>Var nameValue() As String = line.Split("=")</SourceLine>
   <SourceLine>e.Members.Add(nameValue(0).Trim : nameValue(1).Trim)</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>i = i + 1</SourceLine>
   <SourceLine>Wend</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// The signature is just the name.</SourceLine>
   <SourceLine>e.Signature = e.Name</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Exclude this member?</SourceLine>
   <SourceLine>e.IsExcluded = XKProject.ShouldExcludeMember(e, mOptions)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Return e</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>tag As XKProjectItemTag, lines() As String, ByRef i As Integer</ItemParams>
  <ItemResult>XKEnum</ItemResult>
 </Method>
 <Method>
  <ItemName>ParseEvent</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>Parses a Xojo event handler from `lines` starting at `i` using the data within `tag`.</CodeDescription>
  <PartID>143525887</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function ParseEvent(tag As XKProjectItemTag, lines() As String, ByRef i As Integer) As XKEvent</SourceLine>
   <SourceLine>/// Parses a Xojo event handler from `lines` starting at `i` using the data within `tag`.</SourceLine>
   <SourceLine>///</SourceLine>
   <SourceLine>/// Assumes `lines(i)` is the "#tag Event" line which has been parsed into `tag`.</SourceLine>
   <SourceLine>/// Format:</SourceLine>
   <SourceLine>/// ```</SourceLine>
   <SourceLine>/// (FUNCTION | SUB) NAME LPAREN (Param (COMMA Param)*)? RPAREN (AS TYPE)?</SourceLine>
   <SourceLine>/// Param → PARAM_ARRAY? NAME(LPAREN RPAREN)? AS TYPE (EQUAL VALUE)?</SourceLine>
   <SourceLine>/// ```</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Sanity check.</SourceLine>
   <SourceLine>If i &gt;= lines.LastIndex Then</SourceLine>
   <SourceLine>Raise New XKException("Expected an event handler signature line but instead the parser reached the end.")</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Advance to the signature line.</SourceLine>
   <SourceLine>i = i + 1</SourceLine>
   <SourceLine>Var sigLine As String = lines(i)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Search the signature line.</SourceLine>
   <SourceLine>Var rx As New XKRegex(REGEX_EVENT_FUNCTION_SIG)</SourceLine>
   <SourceLine>If Not rx.Match(sigLine) Then</SourceLine>
   <SourceLine>rx = New XKRegex(REGEX_EVENT_SUB_SIG)</SourceLine>
   <SourceLine>If Not rx.Match(sigLine) Then</SourceLine>
   <SourceLine>Raise New XKException("Expected an event handler signature line.")</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Advance past the signature line index.</SourceLine>
   <SourceLine>i = i + 1</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var e As New XKEvent</SourceLine>
   <SourceLine>e.Name = rx.NamedGroups.Lookup("name", "")</SourceLine>
   <SourceLine>e.ReturnType = rx.NamedGroups.Lookup("return", "")</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>If rx.NamedGroups.Lookup("params", "") &lt;&gt; "" Then</SourceLine>
   <SourceLine>Var params() As String = rx.NamedGroups.Value("params").StringValue.Split(", ")</SourceLine>
   <SourceLine>Var paramRx As New XKRegex(REGEX_PARAM)</SourceLine>
   <SourceLine>For Each param As String In params</SourceLine>
   <SourceLine>If Not paramRx.Match(param) Then</SourceLine>
   <SourceLine>Raise New XKException("Invalid parameter within an event handler signature.")</SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine>Var p As New XKParameter</SourceLine>
   <SourceLine>p.DefaultValue = paramRx.NamedGroups.Lookup("default", "")</SourceLine>
   <SourceLine>p.IsParamArray = If(paramRx.NamedGroups.Lookup("isParamArray", "") = "", False, True)</SourceLine>
   <SourceLine>p.Name = paramRx.NamedGroups.Lookup("name", "")</SourceLine>
   <SourceLine>p.IsArray = If(p.Name.IndexOf("(") = -1, False, True)</SourceLine>
   <SourceLine>p.Type = paramRx.NamedGroups.Lookup("type", "")</SourceLine>
   <SourceLine>e.Parameters.Add(p)</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>Next param</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>e.Description = tag.Description</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>While i &lt;= lines.LastIndex</SourceLine>
   <SourceLine>Var line As String = lines(i).Trim(&amp;u09)</SourceLine>
   <SourceLine>If line.BeginsWith("End Sub") Or line.BeginsWith("End Function") Or line.BeginsWith("#tag") Then Exit</SourceLine>
   <SourceLine>e.Lines.Add(line)</SourceLine>
   <SourceLine>i = i + 1</SourceLine>
   <SourceLine>Wend</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Compute the event's signature.</SourceLine>
   <SourceLine>e.Signature = ComputeEventSignature(e)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Exclude this member?</SourceLine>
   <SourceLine>e.IsExcluded = XKProject.ShouldExcludeMember(e, mOptions)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Return e</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>tag As XKProjectItemTag, lines() As String, ByRef i As Integer</ItemParams>
  <ItemResult>XKEvent</ItemResult>
 </Method>
 <Method>
  <ItemName>ParseEventDefinition</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>Parses an event definition from `lines` starting at `i` using the data within `tag`</CodeDescription>
  <PartID>901249023</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function ParseEventDefinition(tag As XKProjectItemTag, lines() As String, ByRef i As Integer) As XKEventDefinition</SourceLine>
   <SourceLine>/// Parses an event definition from `lines` starting at `i` using the data within `tag`</SourceLine>
   <SourceLine>///</SourceLine>
   <SourceLine>/// Assumes `lines(i)` is the "#tag Hook" line which has been parsed into `tag`.</SourceLine>
   <SourceLine>/// Format:</SourceLine>
   <SourceLine>/// ```</SourceLine>
   <SourceLine>/// Attributes? EVENT NAME LPAREN (Param (COMMA Param)*)? RPAREN (AS TYPE)?</SourceLine>
   <SourceLine>/// Attributes → ATTRIBUTES( KeyValue (COMMA KeyValue)* )</SourceLine>
   <SourceLine>/// Param → PARAM_ARRAY? NAME(LPAREN RPAREN)? AS TYPE (EQUAL VALUE)?</SourceLine>
   <SourceLine>/// ```</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Sanity check.</SourceLine>
   <SourceLine>If i &gt;= lines.LastIndex Then</SourceLine>
   <SourceLine>Raise New XKException("Expected an event definition signature line but instead the parser reached the end.")</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Advance to the signature line.</SourceLine>
   <SourceLine>i = i + 1</SourceLine>
   <SourceLine>Var sigLine As String = lines(i)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Search the signature line.</SourceLine>
   <SourceLine>Var rx As New XKRegex(REGEX_EVENT_DEF_FUNCTION_SIG)</SourceLine>
   <SourceLine>If Not rx.Match(sigLine) Then</SourceLine>
   <SourceLine>rx = New XKRegex(REGEX_EVENT_DEF_SUB_SIG)</SourceLine>
   <SourceLine>If Not rx.Match(sigLine) Then</SourceLine>
   <SourceLine>Raise New XKException("Expected an event definition signature line.")</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Advance past the signature line index.</SourceLine>
   <SourceLine>i = i + 1</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var ed As New XKEventDefinition</SourceLine>
   <SourceLine>ed.Name = rx.NamedGroups.Lookup("name", "")</SourceLine>
   <SourceLine>ed.ReturnType = rx.NamedGroups.Lookup("return", "")</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>If rx.NamedGroups.Lookup("Attributes", "") &lt;&gt; "" Then</SourceLine>
   <SourceLine>// Remove "Attributes (" and the trailing ")".</SourceLine>
   <SourceLine>Var attValue As String = rx.NamedGroups.Value("Attributes")</SourceLine>
   <SourceLine>attValue = attValue.Replace("Attributes( ", "").Replace(")", "").Trim</SourceLine>
   <SourceLine>Var attPairs() As String = attValue.Split(", ")</SourceLine>
   <SourceLine>For Each attPair As String In attPairs</SourceLine>
   <SourceLine>Var nameValue() As String = attPair.Split(" = ")</SourceLine>
   <SourceLine>If nameValue.Count = 1 Then</SourceLine>
   <SourceLine>ed.Attributes_.Add(nameValue(0) : "")</SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine>ed.Attributes_.Add(nameValue(0) : nameValue(1))</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>Next attPair</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>If rx.NamedGroups.Lookup("params", "") &lt;&gt; "" Then</SourceLine>
   <SourceLine>Var params() As String = rx.NamedGroups.Value("params").StringValue.Split(", ")</SourceLine>
   <SourceLine>Var paramRx As New XKRegex(REGEX_PARAM)</SourceLine>
   <SourceLine>For Each param As String In params</SourceLine>
   <SourceLine>If Not paramRx.Match(param) Then</SourceLine>
   <SourceLine>Raise New XKException("Invalid parameter within an event definition's signature.")</SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine>Var p As New XKParameter</SourceLine>
   <SourceLine>p.DefaultValue = paramRx.NamedGroups.Lookup("default", "")</SourceLine>
   <SourceLine>p.IsParamArray = If(paramRx.NamedGroups.Lookup("isParamArray", "") = "", False, True)</SourceLine>
   <SourceLine>p.Name = paramRx.NamedGroups.Lookup("name", "")</SourceLine>
   <SourceLine>p.IsArray = If(p.Name.IndexOf("(") = -1, False, True)</SourceLine>
   <SourceLine>p.Type = paramRx.NamedGroups.Lookup("type", "")</SourceLine>
   <SourceLine>ed.Parameters.Add(p)</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>Next param</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>ed.Description = tag.Description</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Compute the event definition's signature and parameter string.</SourceLine>
   <SourceLine>ComputeEventDefinitionSignatureAndParameterString(ed)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Exclude this member?</SourceLine>
   <SourceLine>ed.IsExcluded = XKProject.ShouldExcludeMember(ed, mOptions)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Return ed</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>tag As XKProjectItemTag, lines() As String, ByRef i As Integer</ItemParams>
  <ItemResult>XKEventDefinition</ItemResult>
 </Method>
 <Method>
  <ItemName>ParseGetter</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>Parses a getter of a computed property returning its lines of code (which may be empty). Advances `i` beyond the `#tag EndGetter` line.</CodeDescription>
  <PartID>1385582591</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function ParseGetter(lines() As String, ByRef i As Integer) As String()</SourceLine>
   <SourceLine>/// Parses a getter of a computed property returning its lines of code (which may be empty).</SourceLine>
   <SourceLine>/// Advances `i` beyond the `#tag EndGetter` line.</SourceLine>
   <SourceLine>///</SourceLine>
   <SourceLine>/// Assumes `lines(i) = #tag Getter`</SourceLine>
   <SourceLine>/// Getter → #TAG GETTER EOL GET EOL (CODE_LINE)* END GET #TAG END_GETTER</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var code() As String</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>If i &gt;= lines.LastIndex Then</SourceLine>
   <SourceLine>Raise New XKException("Expected a `Get` line but instead the parser reached the end.")</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Advance past the "#tag Getter" line.</SourceLine>
   <SourceLine>i = i + 1</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>If lines(i).Trim &lt;&gt; "Get" Then</SourceLine>
   <SourceLine>Raise New XKException("Expected a `Get` line but instead the parser reached the end.")</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>If i &gt;= lines.LastIndex Then</SourceLine>
   <SourceLine>Raise New XKException("Expected the contents of a getter but instead the parser reached the end.")</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Advance past the "Get" line.</SourceLine>
   <SourceLine>i = i + 1</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Consume the contents of the getter.</SourceLine>
   <SourceLine>While i &lt;= lines.LastIndex</SourceLine>
   <SourceLine>Var line As String = lines(i).Trim(&amp;u09)</SourceLine>
   <SourceLine>If line = "End Get" Then</SourceLine>
   <SourceLine>i = i + 1</SourceLine>
   <SourceLine>Exit</SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine>code.Add(line)</SourceLine>
   <SourceLine>i = i + 1</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>Wend</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Expect to see "#tag EndGetter"</SourceLine>
   <SourceLine>If lines(i).Trim.BeginsWith("#tag EndGetter") Then</SourceLine>
   <SourceLine>i = i + 1</SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine>Raise New XKException("Expected to see a `#tag EndGetter` line but did not.")</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Return code</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>lines() As String, ByRef i As Integer</ItemParams>
  <ItemResult>String()</ItemResult>
 </Method>
 <Method>
  <ItemName>ParseInterfaceTag</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>Parses an "Interface" tag. Mutates `i`. May raise a `XodocException`.</CodeDescription>
  <PartID>112371711</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Sub ParseInterfaceTag(ByRef item As XKItem, lines() As String, ByRef i As Integer)</SourceLine>
   <SourceLine>/// Parses an "Interface" tag. Mutates `i`. May raise a `XKException`.</SourceLine>
   <SourceLine>///</SourceLine>
   <SourceLine>/// Assumes `lines` is the contents of `file`.</SourceLine>
   <SourceLine>/// Assumes `i` is the index in `lines` of a "#tag Interface" line.</SourceLine>
   <SourceLine>/// Sets the required properties on `item` for this interface.</SourceLine>
   <SourceLine>///</SourceLine>
   <SourceLine>/// #tag Interface format:</SourceLine>
   <SourceLine>/// ```</SourceLine>
   <SourceLine>/// #tag Interface</SourceLine>
   <SourceLine>/// (Attributes LPAREN AttributeKeyValue (COMMA AttributeKeyValue)* RPAREN)? Scope CLASS CLASS_NAME</SourceLine>
   <SourceLine>/// (IMPLEMENTS FQN (COMMA FQN)*)?</SourceLine>
   <SourceLine>/// ...</SourceLine>
   <SourceLine>/// #tag EndInterface</SourceLine>
   <SourceLine>/// ```</SourceLine>
   <SourceLine>///</SourceLine>
   <SourceLine>/// AttributeKeyValue → ATTRIBUTE (EQUAL VALUE)?</SourceLine>
   <SourceLine>/// Scope             → PROTECTED | PRIVATE</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// The file must be an interface.</SourceLine>
   <SourceLine>item.Type = XojoKit.ItemTypes.Interface_</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Sanity check.</SourceLine>
   <SourceLine>If i &gt;= lines.LastIndex Then</SourceLine>
   <SourceLine>Raise New XKException("Expected a scope / attributes line after the Interface tag. " + _</SourceLine>
   <SourceLine>"Instead the parser ran out of lines.")</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// ===============</SourceLine>
   <SourceLine>// SCOPE LINE</SourceLine>
   <SourceLine>// ===============</SourceLine>
   <SourceLine>// The next line must be the scope +/- attributes line.</SourceLine>
   <SourceLine>Var scopeLine As String = lines(i + 1).Trim</SourceLine>
   <SourceLine>i = i + 1</SourceLine>
   <SourceLine>Var hasAttributes As Boolean = False</SourceLine>
   <SourceLine>If scopeLine.BeginsWith("Attributes") Then</SourceLine>
   <SourceLine>hasAttributes = True</SourceLine>
   <SourceLine>ElseIf scopeLine.BeginsWith("Protected") = False And scopeLine.BeginsWith("Private") = False Then</SourceLine>
   <SourceLine>Raise New XKException("Expected a scope / attributes line after the Interface tag.")</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Get the optional "implements" line.</SourceLine>
   <SourceLine>Var implementsLine As String</SourceLine>
   <SourceLine>If i &lt; lines.LastIndex Then</SourceLine>
   <SourceLine>implementsLine = lines(i + 1).Trim</SourceLine>
   <SourceLine>If implementsLine.BeginsWith("Implements") Then</SourceLine>
   <SourceLine>i = i + 1</SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine>implementsLine = ""</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Optional attributes?</SourceLine>
   <SourceLine>If hasAttributes Then</SourceLine>
   <SourceLine>Var attrString As String = scopeLine.Left(scopeLine.IndexOf(")") + 1)</SourceLine>
   <SourceLine>scopeLine = scopeLine.Replace(attrString, "").Trim</SourceLine>
   <SourceLine>attrString = attrString.Replace("Attributes (", "")</SourceLine>
   <SourceLine>attrString = attrString.Replace(")", "")</SourceLine>
   <SourceLine>attrString = attrString.Trim</SourceLine>
   <SourceLine>Var attributeKeyValues() As String = attrString.Split(", ")</SourceLine>
   <SourceLine>For Each keyValue As String In attributeKeyValues</SourceLine>
   <SourceLine>Var kv() As String = keyValue.Split(" = ")</SourceLine>
   <SourceLine>If kv.Count &gt; 1 Then</SourceLine>
   <SourceLine>item.Attributes_.Add(kv(0).Trim : kv(1).Trim)</SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine>item.Attributes_.Add(kv(0).Trim : "")</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>Next keyValue</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Scope.</SourceLine>
   <SourceLine>If scopeLine.BeginsWith("Private") Then</SourceLine>
   <SourceLine>item.Scope = XojoKit.Scopes.Private_</SourceLine>
   <SourceLine>ElseIf scopeLine.BeginsWith("Protected") Then</SourceLine>
   <SourceLine>item.Scope = XojoKit.Scopes.Protected_</SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine>Raise New XKException("Unknown interface scope in file `" + item.File.NativePath + "`.")</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Optional interfaces?</SourceLine>
   <SourceLine>If Not implementsLine.IsEmpty Then</SourceLine>
   <SourceLine>implementsLine = implementsLine.Replace("Implements", "").Trim</SourceLine>
   <SourceLine>Var interfaces() As String = implementsLine.Split(",")</SourceLine>
   <SourceLine>For Each inter As String In interfaces</SourceLine>
   <SourceLine>item.ImplementedInterfaces.Add(inter.Trim)</SourceLine>
   <SourceLine>Next inter</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>End Sub</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>ByRef item As XKItem, lines() As String, ByRef i As Integer</ItemParams>
  <ItemResult></ItemResult>
 </Method>
 <Method>
  <ItemName>ParseMethod</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>Parses a Xojo method from `lines` starting at `i` using the data within `tag`.</CodeDescription>
  <PartID>463495167</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function ParseMethod(tag As XKProjectItemTag, lines() As String, ByRef i As Integer) As XKMethod</SourceLine>
   <SourceLine>/// Parses a Xojo method from `lines` starting at `i` using the data within `tag`.</SourceLine>
   <SourceLine>///</SourceLine>
   <SourceLine>/// Assumes `lines(i)` is the "#tag Method" line which has been parsed into `tag`.</SourceLine>
   <SourceLine>/// Format:</SourceLine>
   <SourceLine>/// ```</SourceLine>
   <SourceLine>/// Attributes? Scope? (SHARED)? (FUNCTION | SUB) NAME LPAREN (Param (COMMA Param)*)? RPAREN (AS TYPE)?</SourceLine>
   <SourceLine>/// Attributes → ATTRIBUTES( KeyValue (COMMA KeyValue)* )</SourceLine>
   <SourceLine>/// Scope → PUBLIC | GLOBAL | PROTECTED | PRIVATE</SourceLine>
   <SourceLine>/// Param → PARAM_ARRAY? NAME(LPAREN RPAREN)? AS TYPE (EQUAL VALUE)?</SourceLine>
   <SourceLine>/// ```</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Sanity check.</SourceLine>
   <SourceLine>If i &gt;= lines.LastIndex Then</SourceLine>
   <SourceLine>Raise New XKException("Expected a method signature line but instead the parser reached the end.")</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Advance to the signature line.</SourceLine>
   <SourceLine>i = i + 1</SourceLine>
   <SourceLine>Var sigLine As String = lines(i)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Search the signature line.</SourceLine>
   <SourceLine>Var rx As New XKRegex(REGEX_FUNCTION_SIG)</SourceLine>
   <SourceLine>If Not rx.Match(sigLine) Then</SourceLine>
   <SourceLine>rx = New XKRegex(REGEX_SUB_SIG)</SourceLine>
   <SourceLine>If Not rx.Match(sigLine) Then</SourceLine>
   <SourceLine>Raise New XKException("Expected a method signature line.")</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Advance past the signature line index.</SourceLine>
   <SourceLine>i = i + 1</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var m As New XKMethod</SourceLine>
   <SourceLine>m.IsShared = If(rx.NamedGroups.Lookup("shared", "") = "Shared", True, False)</SourceLine>
   <SourceLine>m.Name = rx.NamedGroups.Lookup("name", "")</SourceLine>
   <SourceLine>m.ReturnType = rx.NamedGroups.Lookup("return", "")</SourceLine>
   <SourceLine>m.Scope = XojoKit.ScopeFromString(rx.NamedGroups.Lookup("scope", ""))</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>If rx.NamedGroups.Lookup("Attributes", "") &lt;&gt; "" Then</SourceLine>
   <SourceLine>// Remove "Attributes (" and the trailing ")".</SourceLine>
   <SourceLine>Var attValue As String = rx.NamedGroups.Value("Attributes")</SourceLine>
   <SourceLine>attValue = attValue.Replace("Attributes( ", "").Replace(")", "").Trim</SourceLine>
   <SourceLine>Var attPairs() As String = attValue.Split(", ")</SourceLine>
   <SourceLine>For Each attPair As String In attPairs</SourceLine>
   <SourceLine>Var nameValue() As String = attPair.Split(" = ")</SourceLine>
   <SourceLine>If nameValue.Count = 1 Then</SourceLine>
   <SourceLine>m.Attributes_.Add(nameValue(0) : "")</SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine>m.Attributes_.Add(nameValue(0) : nameValue(1))</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>Next attPair</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>If rx.NamedGroups.Lookup("params", "") &lt;&gt; "" Then</SourceLine>
   <SourceLine>Var params() As String = rx.NamedGroups.Value("params").StringValue.Split(", ")</SourceLine>
   <SourceLine>Var paramRx As New XKRegex(REGEX_PARAM)</SourceLine>
   <SourceLine>For Each param As String In params</SourceLine>
   <SourceLine>If Not paramRx.Match(param) Then</SourceLine>
   <SourceLine>Raise New XKException("Invalid parameter within a method signature.")</SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine>Var p As New XKParameter</SourceLine>
   <SourceLine>p.DefaultValue = paramRx.NamedGroups.Lookup("default", "")</SourceLine>
   <SourceLine>p.IsParamArray = If(paramRx.NamedGroups.Lookup("isParamArray", "") = "", False, True)</SourceLine>
   <SourceLine>p.IsAssigns = If(paramRx.NamedGroups.Lookup("isAssigns", "") = "", False, True)</SourceLine>
   <SourceLine>p.Name = paramRx.NamedGroups.Lookup("name", "")</SourceLine>
   <SourceLine>p.IsArray = If(p.Name.IndexOf("(") = -1, False, True)</SourceLine>
   <SourceLine>p.Type = paramRx.NamedGroups.Lookup("type", "")</SourceLine>
   <SourceLine>m.Parameters.Add(p)</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>Next param</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>m.Description = tag.Description</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>While i &lt;= lines.LastIndex</SourceLine>
   <SourceLine>Var line As String = lines(i).TrimLeft(&amp;u09)</SourceLine>
   <SourceLine>If line.BeginsWith("End Sub") Or line.BeginsWith("End Function") Or line.BeginsWith("#tag") Then Exit</SourceLine>
   <SourceLine>m.Lines.Add(line)</SourceLine>
   <SourceLine>i = i + 1</SourceLine>
   <SourceLine>Wend</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Compute the method's signature and parameter string.</SourceLine>
   <SourceLine>ComputeMethodSignatureAndParameterString(m)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Exclude this member?</SourceLine>
   <SourceLine>m.IsExcluded = XKProject.ShouldExcludeMember(m, mOptions)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Return m</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>tag As XKProjectItemTag, lines() As String, ByRef i As Integer</ItemParams>
  <ItemResult>XKMethod</ItemResult>
 </Method>
 <Method>
  <ItemName>ParseModuleTag</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>Parses a "Module" tag. Mutates `i`. May raise a `XodocException`.</CodeDescription>
  <PartID>1276506111</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Sub ParseModuleTag(ByRef item As XKItem, lines() As String, ByRef i As Integer)</SourceLine>
   <SourceLine>/// Parses a "Module" tag. Mutates `i`. May raise a `XKException`.</SourceLine>
   <SourceLine>///</SourceLine>
   <SourceLine>/// Assumes `lines` is the contents of `file`.</SourceLine>
   <SourceLine>/// Assumes `i` is the index in `lines` of a "#tag Module" line.</SourceLine>
   <SourceLine>/// Sets the required properties on `item` for this module.</SourceLine>
   <SourceLine>///</SourceLine>
   <SourceLine>/// #tag Module format:</SourceLine>
   <SourceLine>/// ```</SourceLine>
   <SourceLine>/// #tag Module</SourceLine>
   <SourceLine>/// (Attributes LPAREN AttributeKeyValue (COMMA AttributeKeyValue)* RPAREN)? Scope MODULE MODULE_NAME</SourceLine>
   <SourceLine>/// ...</SourceLine>
   <SourceLine>/// #tag EndModule</SourceLine>
   <SourceLine>/// </SourceLine>
   <SourceLine>/// ```</SourceLine>
   <SourceLine>///</SourceLine>
   <SourceLine>/// Scope → PROTECTED | PRIVATE</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// The file must be a module.</SourceLine>
   <SourceLine>item.Type = XojoKit.ItemTypes.Module_</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Sanity check.</SourceLine>
   <SourceLine>If i &gt;= lines.LastIndex Then</SourceLine>
   <SourceLine>Raise New XKException("Expected a scope / attributes line after the Module tag. " + _</SourceLine>
   <SourceLine>"Instead the parser ran out of lines.")</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// ===============</SourceLine>
   <SourceLine>// SCOPE LINE</SourceLine>
   <SourceLine>// ===============</SourceLine>
   <SourceLine>// The next line must be the scope +/- attributes line.</SourceLine>
   <SourceLine>Var scopeLine As String = lines(i + 1).Trim</SourceLine>
   <SourceLine>i = i + 1</SourceLine>
   <SourceLine>Var hasAttributes As Boolean = False</SourceLine>
   <SourceLine>If scopeLine.BeginsWith("Attributes") Then</SourceLine>
   <SourceLine>hasAttributes = True</SourceLine>
   <SourceLine>ElseIf scopeLine.BeginsWith("Protected") = False And scopeLine.BeginsWith("Private") = False Then</SourceLine>
   <SourceLine>Raise New XKException("Expected a scope / attributes line after the Module tag.")</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Optional attributes?</SourceLine>
   <SourceLine>If hasAttributes Then</SourceLine>
   <SourceLine>Var attrString As String = scopeLine.Left(scopeLine.IndexOf(")") + 1)</SourceLine>
   <SourceLine>scopeLine = scopeLine.Replace(attrString, "").Trim</SourceLine>
   <SourceLine>attrString = attrString.Replace("Attributes (", "")</SourceLine>
   <SourceLine>attrString = attrString.Replace(")", "")</SourceLine>
   <SourceLine>attrString = attrString.Trim</SourceLine>
   <SourceLine>Var attributeKeyValues() As String = attrString.Split(", ")</SourceLine>
   <SourceLine>For Each keyValue As String In attributeKeyValues</SourceLine>
   <SourceLine>Var kv() As String = keyValue.Split(" = ")</SourceLine>
   <SourceLine>If kv.Count &gt; 1 Then</SourceLine>
   <SourceLine>item.Attributes_.Add(kv(0).Trim : kv(1).Trim)</SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine>item.Attributes_.Add(kv(0).Trim : "")</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>Next keyValue</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Scope.</SourceLine>
   <SourceLine>If scopeLine.BeginsWith("Private") Then</SourceLine>
   <SourceLine>item.Scope = XojoKit.Scopes.Private_</SourceLine>
   <SourceLine>ElseIf scopeLine.BeginsWith("Protected") Then</SourceLine>
   <SourceLine>item.Scope = XojoKit.Scopes.Protected_</SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine>Raise New XKException("Unknown module scope in file `" + item.File.NativePath + "`.")</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Sub</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>ByRef item As XKItem, lines() As String, ByRef i As Integer</ItemParams>
  <ItemResult></ItemResult>
 </Method>
 <Method>
  <ItemName>ParseNote</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>1168678911</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function ParseNote(tag As XKProjectItemTag, lines() As String, ByRef i As Integer) As XKNote</SourceLine>
   <SourceLine>/// Parses a note from `lines` starting at `i` using the data within `tag`</SourceLine>
   <SourceLine>///</SourceLine>
   <SourceLine>/// Assumes `lines(i)` is the "#tag Note" line which has been parsed into `tag`.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Sanity check.</SourceLine>
   <SourceLine>If i &gt;= lines.LastIndex Then</SourceLine>
   <SourceLine>Raise New XKException("Expected a some content within the notebut instead the parser reached the end.")</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var note As New XKNote</SourceLine>
   <SourceLine>note.Name = tag.Name</SourceLine>
   <SourceLine>note.Description = tag.Description</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Get the contents of the note.</SourceLine>
   <SourceLine>i = i + 1</SourceLine>
   <SourceLine>While i &lt;= lines.LastIndex</SourceLine>
   <SourceLine>Var line As String = lines(i).TrimLeft</SourceLine>
   <SourceLine>If line.BeginsWith("#tag EndNote") Then Exit</SourceLine>
   <SourceLine>note.Lines.Add(line)</SourceLine>
   <SourceLine>i = i + 1</SourceLine>
   <SourceLine>Wend</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Tidy the note up by removing flanking whitespace.</SourceLine>
   <SourceLine>Var s As String = String.FromArray(note.Lines, EndOfLine.UNIX)</SourceLine>
   <SourceLine>s = s.Trim</SourceLine>
   <SourceLine>note.Lines = s.Split(EndOfLine.UNIX)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// The signature is just the name.</SourceLine>
   <SourceLine>note.Signature = note.Name</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Exclude this member?</SourceLine>
   <SourceLine>note.IsExcluded = XKProject.ShouldExcludeMember(note, mOptions)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Return note</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>tag As XKProjectItemTag, lines() As String, ByRef i As Integer</ItemParams>
  <ItemResult>XKNote</ItemResult>
 </Method>
 <Method>
  <ItemName>ParseProperty</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>Parses a Xojo property from `lines` starting at `i` using the data within `tag`.</CodeDescription>
  <PartID>520280063</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function ParseProperty(tag As XKProjectItemTag, lines() As String, ByRef i As Integer) As XKProperty</SourceLine>
   <SourceLine>/// Parses a Xojo property from `lines` starting at `i` using the data within `tag`.</SourceLine>
   <SourceLine>///</SourceLine>
   <SourceLine>/// Assumes `lines(i)` is the "#tag Property" line which has been parsed into `tag`.</SourceLine>
   <SourceLine>/// Format:</SourceLine>
   <SourceLine>/// ```</SourceLine>
   <SourceLine>/// Attributes? Scope? (SHARED)? NAME (LPAREN RPAREN)?</SourceLine>
   <SourceLine>/// Attributes → ATTRIBUTES( KeyValue (COMMA KeyValue)* )</SourceLine>
   <SourceLine>/// Scope → PUBLIC | GLOBAL | PROTECTED | PRIVATE</SourceLine>
   <SourceLine>/// ```</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Sanity check.</SourceLine>
   <SourceLine>If i &gt;= lines.LastIndex Then</SourceLine>
   <SourceLine>Raise New XKException("Expected a property signature line but instead the parser reached the end.")</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var prop As New XKProperty(XojoKit.MemberTypes.Property_)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Advance to first line after the #tag Property. It's likely the signature but could be a note tag.</SourceLine>
   <SourceLine>i = i + 1</SourceLine>
   <SourceLine>Var firstLine As String = lines(i)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Optional note?</SourceLine>
   <SourceLine>If firstLine.Trim.BeginsWith("#tag Note") Then</SourceLine>
   <SourceLine>i = i + 1</SourceLine>
   <SourceLine>While i &lt;= lines.LastIndex</SourceLine>
   <SourceLine>Var line As String = lines(i).Trim</SourceLine>
   <SourceLine>If line = "#tag EndNote" Then</SourceLine>
   <SourceLine>i = i + 1</SourceLine>
   <SourceLine>Exit</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>prop.NoteLines.Add(line)</SourceLine>
   <SourceLine>i = i + 1</SourceLine>
   <SourceLine>Wend</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var sigLine As String = lines(i)</SourceLine>
   <SourceLine>// Search the signature line.</SourceLine>
   <SourceLine>Var rx As New XKRegex(REGEX_PROP_SIG)</SourceLine>
   <SourceLine>If Not rx.Match(sigLine) Then</SourceLine>
   <SourceLine>Raise New XKException("Expected a property signature line.")</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Advance past the signature line index.</SourceLine>
   <SourceLine>i = i + 1</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>prop.IsShared = If(rx.NamedGroups.Lookup("shared", "") = "Shared", True, False)</SourceLine>
   <SourceLine>prop.Name = rx.NamedGroups.Lookup("name", "")</SourceLine>
   <SourceLine>prop.IsArray = If(prop.Name.IndexOf("(") = -1, False, True)</SourceLine>
   <SourceLine>prop.Scope = XojoKit.ScopeFromString(rx.NamedGroups.Lookup("scope", ""))</SourceLine>
   <SourceLine>prop.Type = rx.NamedGroups.Lookup("type", "")</SourceLine>
   <SourceLine>prop.DefaultValue = rx.NamedGroups.Lookup("default", "")</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>If rx.NamedGroups.Lookup("Attributes", "") &lt;&gt; "" Then</SourceLine>
   <SourceLine>// Remove "Attributes (" and the trailing ")".</SourceLine>
   <SourceLine>Var attValue As String = rx.NamedGroups.Value("Attributes")</SourceLine>
   <SourceLine>attValue = attValue.Replace("Attributes( ", "").Replace(")", "").Trim</SourceLine>
   <SourceLine>Var attPairs() As String = attValue.Split(", ")</SourceLine>
   <SourceLine>For Each attPair As String In attPairs</SourceLine>
   <SourceLine>Var nameValue() As String = attPair.Split(" = ")</SourceLine>
   <SourceLine>If nameValue.Count = 1 Then</SourceLine>
   <SourceLine>prop.Attributes_.Add(nameValue(0) : "")</SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine>prop.Attributes_.Add(nameValue(0) : nameValue(1))</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>Next attPair</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>prop.Description = tag.Description</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// The signature is just the name.</SourceLine>
   <SourceLine>prop.Signature = prop.Name</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Exclude this member?</SourceLine>
   <SourceLine>prop.IsExcluded = XKProject.ShouldExcludeMember(prop, mOptions)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Return prop</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>tag As XKProjectItemTag, lines() As String, ByRef i As Integer</ItemParams>
  <ItemResult>XKProperty</ItemResult>
 </Method>
 <Method>
  <ItemName>ParseSetter</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>Parses a setter of a computed property returning its lines of code (which may be empty). Advances `i` beyond the `#tag EndSetter` line.</CodeDescription>
  <PartID>1664999423</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function ParseSetter(lines() As String, ByRef i As Integer) As String()</SourceLine>
   <SourceLine>/// Parses a setter of a computed property returning its lines of code (which may be empty).</SourceLine>
   <SourceLine>/// Advances `i` beyond the `#tag EndSetter` line.</SourceLine>
   <SourceLine>///</SourceLine>
   <SourceLine>/// Assumes `lines(i) = #tag Setter`</SourceLine>
   <SourceLine>/// Getter → #TAG SETTER EOL SET EOL (CODE_LINE)* END SET #TAG END_SETTER</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var code() As String</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>If i &gt;= lines.LastIndex Then</SourceLine>
   <SourceLine>Raise New XKException("Expected a `Set` line but instead the parser reached the end.")</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Advance past the "#tag Setter" line.</SourceLine>
   <SourceLine>i = i + 1</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>If lines(i).Trim &lt;&gt; "Set" Then</SourceLine>
   <SourceLine>Raise New XKException("Expected a `Set` line but instead the parser reached the end.")</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>If i &gt;= lines.LastIndex Then</SourceLine>
   <SourceLine>Raise New XKException("Expected the contents of a setter but instead the parser reached the end.")</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Advance past the "Set" line.</SourceLine>
   <SourceLine>i = i + 1</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Consume the contents of the setter.</SourceLine>
   <SourceLine>While i &lt;= lines.LastIndex</SourceLine>
   <SourceLine>Var line As String = lines(i).Trim(&amp;u09)</SourceLine>
   <SourceLine>If line = "End Set" Then</SourceLine>
   <SourceLine>i = i + 1</SourceLine>
   <SourceLine>Exit</SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine>code.Add(line)</SourceLine>
   <SourceLine>i = i + 1</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>Wend</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Expect to see "#tag EndSetter"</SourceLine>
   <SourceLine>If lines(i).Trim.BeginsWith("#tag EndSetter") Then</SourceLine>
   <SourceLine>i = i + 1</SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine>Raise New XKException("Expected to see a `#tag EndSetter` line but did not.")</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Return code</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>lines() As String, ByRef i As Integer</ItemParams>
  <ItemResult>String()</ItemResult>
 </Method>
 <Method>
  <ItemName>ParseStructure</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>Parses a Xojo structure from `lines` starting at `i` using the data within `tag`</CodeDescription>
  <PartID>1746708479</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function ParseStructure(tag As XKProjectItemTag, lines() As String, ByRef i As Integer) As XKStructure</SourceLine>
   <SourceLine>/// Parses a Xojo structure from `lines` starting at `i` using the data within `tag`</SourceLine>
   <SourceLine>///</SourceLine>
   <SourceLine>/// Assumes `lines(i)` is the "#tag Structure" line which has been parsed into `tag`.</SourceLine>
   <SourceLine>/// Format:</SourceLine>
   <SourceLine>/// ```</SourceLine>
   <SourceLine>/// #TAG STRUCTURE TagProperties</SourceLine>
   <SourceLine>///   (Field)*</SourceLine>
   <SourceLine>/// #TAG ENDSTRUCTURE</SourceLine>
   <SourceLine>///</SourceLine>
   <SourceLine>/// TagProperties      → NAME EQUAL IDENTIFIER, TYPE EQUAL Literal, DYNAMIC EQUAL Boolean, </SourceLine>
   <SourceLine>///                      (FLAGS EQUAL HexLiteral)?, DESCRIPTION EQUAL Base64String, SCOPE EQUAL ScopeString, </SourceLine>
   <SourceLine>///                      DEFAULT EQUAL \"Literal"</SourceLine>
   <SourceLine>/// Scope              → PUBLIC | GLOBAL | PROTECTED | PRIVATE</SourceLine>
   <SourceLine>/// Field → NAME (LPAREN NUMBER RPAREN)? AS FieldType</SourceLine>
   <SourceLine>/// FieldType → TYPE (STAR) NUMBER</SourceLine>
   <SourceLine>/// ```</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Sanity check.</SourceLine>
   <SourceLine>If i &gt;= lines.LastIndex Then</SourceLine>
   <SourceLine>Raise New XKException("Expected a constant declaration line but instead the parser reached the end.")</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var s As New XKStructure</SourceLine>
   <SourceLine>s.Attributes_ = tag.Attributes_</SourceLine>
   <SourceLine>s.Description = tag.Description</SourceLine>
   <SourceLine>s.Name = tag.Name</SourceLine>
   <SourceLine>s.Scope = tag.Scope</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Advance past the #Tag Structure line.</SourceLine>
   <SourceLine>i = i + 1</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Fields?</SourceLine>
   <SourceLine>Var fieldIndex As Integer = -1</SourceLine>
   <SourceLine>While i &lt;= lines.LastIndex</SourceLine>
   <SourceLine>Var line As String = lines(i).Trim</SourceLine>
   <SourceLine>If line.BeginsWith("#tag EndStructure") Then</SourceLine>
   <SourceLine>Exit</SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine>fieldIndex = fieldIndex + 1</SourceLine>
   <SourceLine>If line = "" Then</SourceLine>
   <SourceLine>s.Fields.Add(New XKStructureField(fieldIndex, "", ""))</SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine>Var nameValue() As String = line.Split(" As ")</SourceLine>
   <SourceLine>s.Fields.Add(New XKStructureField(fieldIndex, nameValue(0).Trim, nameValue(1).Trim))</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>i = i + 1</SourceLine>
   <SourceLine>Wend</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// There seems to be a bug in the IDE where an empty field can get appended to the end of the declaration.</SourceLine>
   <SourceLine>If s.Fields.Count &gt; 0 And s.Fields(s.Fields.LastIndex).Name = "" Then</SourceLine>
   <SourceLine>Call s.Fields.Pop</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// The signature is just the name.</SourceLine>
   <SourceLine>s.Signature = s.Name</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Exclude this member?</SourceLine>
   <SourceLine>s.IsExcluded = XKProject.ShouldExcludeMember(s, mOptions)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Return s</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>tag As XKProjectItemTag, lines() As String, ByRef i As Integer</ItemParams>
  <ItemResult>XKStructure</ItemResult>
 </Method>
 <Method>
  <ItemName>ComputeMethodSignatureAndParameterString</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>Computes and assigns the passed method's user-facing signature (less decorations like attributes, etc) and its `parameterString`.</CodeDescription>
  <PartID>430653439</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Sub ComputeMethodSignatureAndParameterString(ByRef m As XKMethod)</SourceLine>
   <SourceLine>/// Computes and assigns the passed method's user-facing signature (less decorations like attributes, etc) and</SourceLine>
   <SourceLine>/// its `parameterString`.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>m.Signature = m.Name + "("</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>For i As Integer = 0 To m.Parameters.LastIndex</SourceLine>
   <SourceLine>Var p As XKParameter = m.Parameters(i)</SourceLine>
   <SourceLine>m.ParameterString = m.ParameterString + p.ToString + If(i &lt; m.Parameters.LastIndex, ", ", "")</SourceLine>
   <SourceLine>Next i</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>m.Signature = m.Signature + m.ParameterString + ")"</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>If m.ReturnType &lt;&gt; "" Then</SourceLine>
   <SourceLine>m.Signature = m.Signature + " As " + m.ReturnType</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Sub</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>ByRef m As XKMethod</ItemParams>
  <ItemResult></ItemResult>
 </Method>
 <Method>
  <ItemName>ComputeEventSignature</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>Computes and returns the passed event's user-facing signature (less decorations like attributes, etc).</CodeDescription>
  <PartID>482846719</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function ComputeEventSignature(e As XKEvent) As String</SourceLine>
   <SourceLine>/// Computes and returns the passed event's user-facing signature (less decorations like attributes, etc).</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var sig as String = e.Name + "("</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>For i As Integer = 0 To e.Parameters.LastIndex</SourceLine>
   <SourceLine>Var p As XKParameter = e.Parameters(i)</SourceLine>
   <SourceLine>sig = sig + p.ToString + If(i &lt; e.Parameters.LastIndex, ", ", "")</SourceLine>
   <SourceLine>Next i</SourceLine>
   <SourceLine>sig = sig + ")"</SourceLine>
   <SourceLine>If e.ReturnType &lt;&gt; "" Then</SourceLine>
   <SourceLine>sig = sig + " As " + e.ReturnType</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Return sig</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>e As XKEvent</ItemParams>
  <ItemResult>String</ItemResult>
 </Method>
 <Method>
  <ItemName>ComputeEventDefinitionSignatureAndParameterString</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>Computes and assigns the passed event definition's user-facing signature (less decorations like attributes, etc) and its `parameterString`.</CodeDescription>
  <PartID>1740480511</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Sub ComputeEventDefinitionSignatureAndParameterString(ByRef e As XKEventDefinition)</SourceLine>
   <SourceLine>/// Computes and assigns the passed event definition's user-facing signature (less decorations like attributes, etc) and</SourceLine>
   <SourceLine>/// its `parameterString`.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>e.Signature = e.Name + "("</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>For i As Integer = 0 To e.Parameters.LastIndex</SourceLine>
   <SourceLine>Var p As XKParameter = e.Parameters(i)</SourceLine>
   <SourceLine>e.ParameterString = e.ParameterString + p.ToString + If(i &lt; e.Parameters.LastIndex, ", ", "")</SourceLine>
   <SourceLine>Next i</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>e.Signature = e.Signature + e.ParameterString + ")"</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>If e.ReturnType &lt;&gt; "" Then</SourceLine>
   <SourceLine>e.Signature = e.Signature + " As " + e.ReturnType</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Sub</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>ByRef e As XKEventDefinition</ItemParams>
  <ItemResult></ItemResult>
 </Method>
 <Method>
  <ItemName>ComputeDelegateSignature</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>Computes and returns the passed delegate's user-facing signature (less decorations like attributes, etc).</CodeDescription>
  <PartID>423811071</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function ComputeDelegateSignature(d As XKDelegate) As String</SourceLine>
   <SourceLine>/// Computes and returns the passed delegate's user-facing signature (less decorations like attributes, etc).</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var sig as String = d.Name + "("</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>For i As Integer = 0 To d.Parameters.LastIndex</SourceLine>
   <SourceLine>Var p As XKParameter = d.Parameters(i)</SourceLine>
   <SourceLine>sig = sig + p.ToString + If(i &lt; d.Parameters.LastIndex, ", ", "")</SourceLine>
   <SourceLine>Next i</SourceLine>
   <SourceLine>sig = sig + ")"</SourceLine>
   <SourceLine>If d.ReturnType &lt;&gt; "" Then</SourceLine>
   <SourceLine>sig = sig + " As " + d.ReturnType</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Return sig</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>d As XKDelegate</ItemParams>
  <ItemResult>String</ItemResult>
 </Method>
 <Method>
  <ItemName>ComputeDelegateSignatureAndParameterString</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>Computes and assigns the passed delegate's user-facing signature (less decorations like attributes, etc) and its `parameterString`.</CodeDescription>
  <PartID>809140223</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Sub ComputeDelegateSignatureAndParameterString(ByRef d As XKDelegate)</SourceLine>
   <SourceLine>/// Computes and assigns the passed delegate's user-facing signature (less decorations like attributes, etc) and</SourceLine>
   <SourceLine>/// its `parameterString`.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>d.Signature = d.Name + "("</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>For i As Integer = 0 To d.Parameters.LastIndex</SourceLine>
   <SourceLine>Var p As XKParameter = d.Parameters(i)</SourceLine>
   <SourceLine>d.ParameterString = d.ParameterString + p.ToString + If(i &lt; d.Parameters.LastIndex, ", ", "")</SourceLine>
   <SourceLine>Next i</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>d.Signature = d.Signature + d.ParameterString + ")"</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>If d.ReturnType &lt;&gt; "" Then</SourceLine>
   <SourceLine>d.Signature = d.Signature + " As " + d.ReturnType</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Sub</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>ByRef d As XKDelegate</ItemParams>
  <ItemResult></ItemResult>
 </Method>
 <Note>
  <ItemName>About</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>156559359</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <NoteLine>About</NoteLine>
   <NoteLine>Parses the contents of a Xojo item serialised to a `.xojo_code` file.</NoteLine>
   <NoteLine></NoteLine>
  </ItemSource>
  <ItemFlags>0</ItemFlags>
 </Note>
 <Property>
  <ItemName>mOptions</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>The options to use when parsing items and members.</CodeDescription>
  <PartID>1388103679</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>mOptions As XKOptions</SourceLine>
   <SourceLine></SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <ItemDeclaration>mOptions As XKOptions</ItemDeclaration>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
 </Property>
 <ViewBehavior>
  <ViewProperty>
   <ObjName>Name</ObjName>
   <Visible>1</Visible>
   <PropertyGroup>ID</PropertyGroup>
   <ItemType>String</ItemType>
  </ViewProperty>
  <ViewProperty>
   <ObjName>Index</ObjName>
   <Visible>1</Visible>
   <PropertyGroup>ID</PropertyGroup>
   <PropertyValue>-2147483648</PropertyValue>
   <ItemType>Integer</ItemType>
  </ViewProperty>
  <ViewProperty>
   <ObjName>Super</ObjName>
   <Visible>1</Visible>
   <PropertyGroup>ID</PropertyGroup>
   <ItemType>String</ItemType>
  </ViewProperty>
  <ViewProperty>
   <ObjName>Left</ObjName>
   <Visible>1</Visible>
   <PropertyGroup>Position</PropertyGroup>
   <PropertyValue>0</PropertyValue>
   <ItemType>Integer</ItemType>
  </ViewProperty>
  <ViewProperty>
   <ObjName>Top</ObjName>
   <Visible>1</Visible>
   <PropertyGroup>Position</PropertyGroup>
   <PropertyValue>0</PropertyValue>
   <ItemType>Integer</ItemType>
  </ViewProperty>
 </ViewBehavior>
 <Constant>
  <ItemName>REGEX_EVENT_DEF_FUNCTION_SIG</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>The regex pattern for matching an event definition signature that returns a value within a `.xojo_code` file.</CodeDescription>
  <PartID>109348863</PartID>
  <TextEncoding>134217984</TextEncoding>
  <ItemType>0</ItemType>
  <ItemDef>(?P&lt;attributes&gt;Attributes\(.+\))?\s?(?:Event)\s(?&lt;name&gt;[a-z0-9_]+)\((?P&lt;params&gt;.+)?\)(?:\sAs\s)(?P&lt;return&gt;.+)</ItemDef>
  <ItemFlags>33</ItemFlags>
 </Constant>
 <Constant>
  <ItemName>REGEX_EVENT_DEF_SUB_SIG</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>The regex pattern for matching an event definition signature that doesn't return a value within a `.xojo_code` file.</CodeDescription>
  <PartID>850386943</PartID>
  <TextEncoding>134217984</TextEncoding>
  <ItemType>0</ItemType>
  <ItemDef>(?P&lt;attributes&gt;Attributes\(.+\))?\s?(?:Event)\s(?&lt;name&gt;[a-z0-9_]+)\((?P&lt;params&gt;.+)?\)</ItemDef>
  <ItemFlags>33</ItemFlags>
 </Constant>
 <Constant>
  <ItemName>REGEX_EVENT_FUNCTION_SIG</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>The regex pattern for matching an event handler's function signature within a `.xojo_code` file.</CodeDescription>
  <PartID>633106431</PartID>
  <TextEncoding>134217984</TextEncoding>
  <ItemType>0</ItemType>
  <ItemDef>(?&lt;type&gt;Function)\s(?&lt;name&gt;[a-z0-9_]+)\((?P&lt;params&gt;.+)?\)(?:\sAs\s)(?P&lt;return&gt;.+)</ItemDef>
  <ItemFlags>33</ItemFlags>
 </Constant>
 <Constant>
  <ItemName>REGEX_EVENT_SUB_SIG</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>The regex pattern for matching an event handler sub within a `.xojo_code` file.</CodeDescription>
  <PartID>1933203455</PartID>
  <TextEncoding>134217984</TextEncoding>
  <ItemType>0</ItemType>
  <ItemDef>(?&lt;type&gt;Sub)\s(?&lt;name&gt;[a-z0-9_]+)\((?P&lt;params&gt;.+)?\)</ItemDef>
  <ItemFlags>33</ItemFlags>
 </Constant>
 <Constant>
  <ItemName>REGEX_FUNCTION_SIG</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>The regex pattern for matching a function signature within a `.xojo_code` file.</CodeDescription>
  <PartID>1681657855</PartID>
  <TextEncoding>134217984</TextEncoding>
  <ItemType>0</ItemType>
  <ItemDef>(?P&lt;attributes&gt;Attributes\(.+\))?\s?(?P&lt;scope&gt;Public|Global|Protected|Private)?\s?(?&lt;shared&gt;Shared)?\s?(?&lt;type&gt;Function)\s(?&lt;name&gt;[a-z0-9_]+)\((?P&lt;params&gt;.+)?\)(?:\sAs\s)(?P&lt;return&gt;.+)</ItemDef>
  <ItemFlags>33</ItemFlags>
 </Constant>
 <Constant>
  <ItemName>REGEX_PARAM</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>The regex to match a single parameter within a signature.</CodeDescription>
  <PartID>1235130367</PartID>
  <TextEncoding>134217984</TextEncoding>
  <ItemType>0</ItemType>
  <ItemDef>(?P&lt;isParamArray&gt;ParamArray)?(?P&lt;isAssigns&gt;Assigns)?\s?(?P&lt;name&gt;[a-z0-9_\.]+(?:\(.*\))?)\sAs\s(?P&lt;type&gt;[a-z0-9_\.]+)(?:\s=\s)?(?P&lt;default&gt;[a-z0-9._"\-\s]+)?</ItemDef>
  <ItemFlags>33</ItemFlags>
 </Constant>
 <Constant>
  <ItemName>REGEX_PROP_SIG</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>The regex for a property signature line.</CodeDescription>
  <PartID>626372607</PartID>
  <TextEncoding>134217984</TextEncoding>
  <ItemType>0</ItemType>
  <ItemDef>(?P&lt;attributes&gt;Attributes\(.+\))?\s?(?P&lt;scope&gt;Public|Global|Protected|Private)?\s?(?&lt;shared&gt;Shared)?\s?(?&lt;name&gt;[a-z0-9_]+(?:\(.*\))?)(?:\sAs\s)(?P&lt;type&gt;[a-z0-9_\.]+\(?,?\)?)?\s?=?\s?(?P&lt;default&gt;[a-z0-9_\."\-\s]+)?$</ItemDef>
  <ItemFlags>33</ItemFlags>
 </Constant>
 <Constant>
  <ItemName>REGEX_SUB_SIG</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <CodeDescription>The regex pattern for matching a sub signature within a `.xojo_code` file.</CodeDescription>
  <PartID>2097833983</PartID>
  <TextEncoding>134217984</TextEncoding>
  <ItemType>0</ItemType>
  <ItemDef>(?P&lt;attributes&gt;Attributes\(.+\))?\s?(?P&lt;scope&gt;Public|Global|Protected|Private)?\s?(?&lt;shared&gt;Shared)?\s?(?&lt;type&gt;Sub)\s(?&lt;name&gt;[a-z0-9_]+)\((?P&lt;params&gt;.+)?\)</ItemDef>
  <ItemFlags>33</ItemFlags>
 </Constant>
</block>
</RBProject>
